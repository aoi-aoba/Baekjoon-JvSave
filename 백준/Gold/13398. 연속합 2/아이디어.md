# 아이디어
다이나믹 프로그래밍 문제는 일반항(수열의 점화식 같은 느낌) 규칙을 잘 정해주기만 하면, 웬만한 건 다 한 셈이다.

## 문제 파악하기
$n$개의 정수로 이뤄진 임의 수열이 주어지고, 이들 중 연속된 몇 개의 수를 선택해 구할 수 있는 합 중 가장 큰 합을 구하려고 한다. 단, 수는 한 개 이상 선택해야 하고, 수열에서 하나의 수를 제거한 상태로 연속 선택이 가능하다.

예를 들어,
> 10, -4, 3, 1, 5, 6, -35, 12, 21, -1

이라는 수열이 주어진다고 하면 최대는 $12 + 21  = 33$일 것이다. 하지만, 한 개를 지울 수 있다고 한다면, $-35$를 지워버리면

> 10, -4, 3, 1, 5, 6, 12, 21, -1

이라는 수열이 되면서 $3 + 1 + 5 + 6 + 12 + 21 = 54$라는 답이 된다.

- 입력으로 첫째 줄에 정수 $n$이 10만 이하의 자연수로 주어진다.
- 둘째 줄에 $n$개 정수의 수열이 주어지고, 수열의 각 항은 절댓값이 1000 이하인 정수이다.
- 출력으로 답을 첫째 줄에 입력하면 된다.

## 방법 고안
일반적으로 연속합을 구하는 문제는 이미 있었다. 하지만 새로운 규칙에 대해 생각해보는 것이 중요할 뿐이다.

### 일반적인 연속합은 어떻게 구했었나
그냥 연속합 자체는, 배열을 만드는 방식으로 합을 구해나가는 것이 답이었다. 가령, 위의 

> 10, -4, 3, 1, 5, 6, -35, 12, 21, -1

수열의 경우는 다음과 같다.

- 첫 수에 대하여 전체 합과 현재 값은 모두 10으로 동일하다.
- 두 번째 수에 대하여 현재 값은 -4, 전체 합은 6이다. sum = 6으로 둔다.
- 세 번째 수에 대하여 현재 값은 3, 이전 sum에 대해 합하면 9이다. 더 큰 값이 9이므로 sum = 9로 둔다.
- 네 번째 수에 대하여 현재 값은 1, 이전 sum에 대해 합하면 10이다. 더 큰 값은 10이므로 sum = 10으로 둔다.
- 다섯 번째 수에 대하여 현재 값은 5, 이전 sum에 대해 합하면 15이다. 더 큰 값은 15이므로 sum = 15로 둔다.
- 여섯 번째 수에 대하여 현재 값은 6, 이전 sum에 대해 합하면 21이다. 더 큰 값은 21이므로 sum = 21로 둔다.
- 일곱 번째 수에 대하여 현재 값은 -35, 이전 sum에 대해 합하면 -14이다. 더 큰 값은 -14이므로 sum = -14로 둔다.
- 여덟 번째 수에 대하여 현재 값은 12, 이전 sum에 대해 합하면 -2가 된다. 이때, 더 큰 값이 12이므로 sum = 12가 된다. 즉, 여기서는 연속합의 의미가 없어지고 계속 이어나가지 않는다는 반증이 된다.
- 아홉 번째 수에 대하여 현재 값은 21, 이전 sum에 대해 합하면 33이다. 더 큰 값은 33이므로 sum = 33이 된다.
- 마지막 수 -1에 대하여 이전 sum에 합하면 32로 -1보다 더 크므로 sum = 32가 된다.

여태까지 나열한 수들에 대하여 저장한 sum들 중 가장 큰 것은 33이었다. 연속합의 최대치는 33이 된다. 배열을 만든다는 것이 위에서 설명한 sum들을 저장하는 배열이다.

배열의 이름을 `sumAll[]`이라 하고, 입력을 저장한 배열을 `input[]`이라고 하자. 그러면, `i`번째 인덱스에 대하여
```java
for (int i = 1; i < N; i++) // i = 0은 자기 자신으로 초기화하기
	sumAll[i] = Math.max(input[i], sumAll[i - 1] + input[i]);
```

인 셈이다.

### 한 개의 숫자를 이제 지워야 하는데?
이것도 직접 한 번 해보면 된다. 딱 한 개의 수만 지울 수 있다는 점에서, 일반화시킬 여지가 충분히 있다. 위에서 있는 `sumAll[]` 배열을 활용해보면 된다.

> 10, -4, 3, 1, 5, 6, -35, 12, 21, -1

- 10에 대하여 10은 그대로 가져간다.
- -4에 대하여, 만약 -4가 제외 대상이라면 합은 10, 이전에 이미 제외 대상 수가 있었다면 (10이 제외 대상이라면) 합은 -4이다. 최대는 10이다.
- 3에 대하여, 만약 3이 제외 대상이라면 합은 이전까지의 합인 6이다. 이전에 이미 제외 대상이 있었다면 이전의 최대 경우 10에 대해 3을 더한 13이다. 최대는 13이다.
- 1에 대하여, 만약 1이 제외 대상이라면 합은 이전까지의 전체 합인 9이다. 이전에 이미 제외 대상이 있었다면, 3에 대하여 최대였던 13에 1을 더한 14이다. 최대는 14이다.
- 5에 대하여, 만약 5가 제외 대상이었다면 합은 이전까지의 전체 합인 10이다. 이전에 이미 제외 대상이 있었다면, 1에 대하여 최대였던 14에 5를 더한 19이다. 최대는 19이다.
- 6에 대하여 같은 방법으로 전자는 6 제외 전체합 15, 후자는 19+6=25이다. 25가 최대이다.
- -35에 대하여 같은 방법으로 전자는 -35를 제외한 전체 합인 21, 후자는 25+(-35) = (-10)이다. 여기에서는 21이 최대이다.
- 12에 대하여 같은 방법으로 전자는 12를 제외한 전체 합인 -14, 후자는 21+12=33이다. 여기에서는 33이 최대이다.
- 21에 대하여, 전자의 경우 앞에서 설명한 최대 합은 `sumAll[]`에서 33이었다. 후자는 33 + 21 = 54이다. 여기에서는 54가 최대이다.
- -1에 대하여, 전자의 경우 앞에서 설명한 최대 합은 `sumAll[]`에서 32였다. 후자는 54 + (-1) = 53이다. 여기서는 53이 최대이다.

즉, 정리하면 아래와 같다:
> 만약 `i`번째 인덱스의 값에 대하여
- CASE A : `i-1`번째까지 이미 지운 수가 한 개 존재한다면 그 값에 `i`를 더한 값
- CASE B : `i-1`번째까지 지운 수가 없고, `i`번째 수를 지워버릴 거라면, `sumAll[]`에서 구했던 `i-1` 인덱스까지의 일반 최대 연속합의 값
- CASE C : 일반적인 연속합을 계속 구해서 그 어떤 수도 빼지 않은 합의 값
>
> 이들 중에서 더 큰 값이 현재 `i` 인덱스에 대한 연속합 규칙의 최댓값이다.

---
이를 기반으로 코드를 구성하면 된다.

## 코드화
### DP 테이블 구성하는 메소드 dp(int N)
```java
public class Main {
    public static int[] input, sumAll, sumNoOne;
    public static int dp(int N) {
        int result = Integer.MIN_VALUE;
        sumAll[0] = sumNoOne[0] = input[0];
        for (int i = 1; i < N; i++) {
            sumAll[i] = Math.max(input[i], sumAll[i - 1] + input[i]);
            sumNoOne[i] = Math.max(sumAll[i - 1], sumNoOne[i - 1] + input[i]);
            // i 번째를 제외한 경우 sumAll[i - 1], i번째 포함했는데 이미 제거한 게 있으면 sumNoOne[i - 1]에 합
        }
        for (int i = 0; i < N; i++) result = Math.max(result, sumAll[i]);
        for (int i = 0; i < N; i++) result = Math.max(result, sumNoOne[i]);
        return result;
    }
```
bottom-up 방식으로 밑에서부터 채워주는 방식을 택했다.
- 위에서 설명한 대로 초기값은 `sumAll[]`과 `sumNoOne[]`(Case A-Case B 비교를 위한 최종배열), `input[]`의 0번 인덱스를 일치시킨다.
- `for` 루프를 돌면서, 1번 인덱스부터
	- `sumAll[]`의 경우 일반적 연속합을 구하는 방식으로 진행한다.
   	- `sumNoOne[]`의 경우 Case A(`sumNoOne[i-1]+input[i]`)와 Case B(`sumAll[i-1]`)을 비교하여 최댓값을 남긴다.

`sumNoOne[]`의 경우에서는 한 개의 수를 무조건 빼게 되어있고, `sumAll[]` 역시 확인해야 하는데, 문제 조건에서 '꼭 빼지 않아도 된다'는 것이 전제되어 있기 때문이다. 그래서 두 개의 배열을 모두 돌며 최댓값을 반환하면 된다.

### 마무리
```java
...
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int N = Integer.parseInt(br.readLine());
        input = new int[N];
        sumAll = new int[N];
        sumNoOne = new int[N];

        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 0; i < N; i++) input[i] = Integer.parseInt(st.nextToken());

        bw.write(String.valueOf(dp(N)));
        bw.flush();
    }
}
```
남은 건 입력을 받아서 적당히 `dp(N)`으로 넘겨준 값을 받아서 출력하면 된다.

## 정리
규칙성을 발견해서 모든 것을 일반화할 수 있는 '수학적 귀납법' 같은 느낌으로 푸는 DP 문제였다.
