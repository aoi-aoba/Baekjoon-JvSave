# 아이디어
문제 풀이의 아이디어는 조금 까다로울 수 있었다.

## check() 함수의 제작
그룹 단어인지 아닌지 파악하는 boolean 함수를 만든다.

**[1] 변수의 선언**
26개의 알파벳을 체크할 boolean 배열을 선언하고    boolean[] check = new boolean[26];
변수 prev에서 앞선 문자를 가지고 있게 한다        int prev = 0;

로직은 이렇다.
1) 만약 prev 문자와 해당 문자가 같다면 → 중복 문자인지 확인할 필요가 없다
2) 만약 prev 문자와 해당 문자가 다르다면 → 중복 문자인지 **확인해봐야 한다**

**[2] 문자열 노가다**
문자열에서 하나씩 문자를 꺼내온다.                for(int i=0; i<str.length(); i++)
검사할 문자 now를 우선 i를 통해 받아오자.         int now = str.charAt(i);

위 로직의 1번에서 prev와 다르다면 중복 문자인지 확인이 필요한데 보면 잘 이해가 안 될수 있다.
예시로 aaba라는 문자열이 있다 치자.

가. 맨 처음 a는 int로 97이고 prev의 **초기값 0과 다르니까** check[0] = true가 되고 prev = 97
나. prev와 다음 글자 a는 모두 97로 **같으므로 확인 없이** 넘어가고
다. 다음 문자 b는 **이전과 다르므로 조건문을 실행**하는데, check[1] = false(초깃값)이므로 처음 나오는 글자
    즉, check[1] = true가 되고 prev = 98
라. 마지막 문자 a는 이전과 다르므로 조건문을 실행하는데, check[0] = **true이므로 중복**
    **이미 나왔다**는 것이므로, 더 이상 단어 여부 체크 없이 false를 return

나머지는 main에서 N회동안 check 함수를 돌리면서 횟수 체크할 변수를 더해가면 그만이다.
