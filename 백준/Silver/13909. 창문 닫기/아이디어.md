# 아이디어
수학 문제는 진짜 머리만 잘 굴리면 코드는 짜기 쉽다.

## 문제 파악하기
N개의 창문에 대해서 N명의 사람들이 줄줄이 창문을 열거나 닫는다.
- 1번째 사람은 1의 배수인 창문을 모두 연다.
- 2번째 사람은 2의 배수인 창문을 모두 닫는다.
- 3번째 사람은 3의 배수인 창문을 닫힌 것은 열고 열린 것은 닫는다.
- 4번째 사람은 4의 배수인 창문을 닫힌 것은 열고 열린 것은 닫는다.

이런 방식으로 진행했을 때, N번째 사람까지 진행한 후 열린 창문은 몇 개인지 출력한다. N은 21억 (`int` 범위를 1억 미만을 버린 형태) 이내로 주어진다.

## 방법 고안
어디선가 본거 같으면서도 뭔가 있을 것 같아서 처음에는 직접 써봤다.

1번 창문 : 1은 소수도 합성수도 아니고 1만 시행되므로 열린다.
2번 창문 : 2는 소수니까 1, 2번이 접근하고 닫힌다.
3번 창문 : 3은 소수니까 1, 3번이  접근하고 닫힌다.
4번 창문 : 4의 약수는 1, 2, 4이므로 이들이 접근해서 열린다.
...

사실 처음에는 시뮬레이션으로 해볼까 싶었는데, N이 21억까지 주어지는데 21억까지 모두 구현하는 것은 시간 복잡도 상으로도 그렇고 전반적으로 메모리 상으로도 무리가 있다. 그래서 좀 더 수학적으로 접근해보기로 했다. 창문이 열린다는 것은 홀수 번 건드려진 창문, 즉 **해당 창문의 N번에 대해 N의 약수의 개수가 홀수**&ZeroWidthSpace;여야만 한다.

---

약수의 개수를 구하는 공식에 대해 생각해보자.   
어떤 합성수 N에 대하여 이를 소인수분해하면 $$N = p_1^a×p_2^b×p_3^c×\dots×p_n^z$$ (단, $$p_n$$은 임의의 소수이며 쌍마다 서로소) 처럼 나타낼 수 있다.   
여기에서 약수의 개수는 **지수에 각각 1씩 더한 곱** 식으로 나타난다.   
즉, $$(a+1)×(b+1)×(c+1)×\dots×(z+1)$$와 같이 나타나는 것이다.   
우리는 이 값이 **홀수인 경우** 한정으로 찾아야 하므로 곱셈의 특성에 의하여 각각 곱해지는 (지수+1) 중 하나라도 **짝수이면 안된다** 라는 조건이 나온다.   
이는 **지수 + 1 = 홀수** 이므로, 모든 소인수에 대하여 **짝수 지수** 형태로 주어져야 한다는 것을 알 수 있다.   
$$N = p_1^{2k_1}×p_2^{2k_2}×p_3^{2k_3}×\dots×p_n^{2k_n}$$에서 지수법칙 $$a^{nm} = (a^n)^m$$을 활용해보자.
$$N = (p_1^{k_1})^2×(p_2^{k_2})^2×(p_3^{k_3})^2×\dots×(p_n^{k_n})^2$$ 이다.   
여기에서 $$(ab)^n = a^n×b^n$$이라는 지수법칙을 활용해준다.
결국 $$N = (p_1^{k_1}×p_2^{k_2}×p_3^{k_3}×\dots×p_n^{k_n})^2 = A^2$$의 꼴로 정리되면서 우리가 찾는 수는 **어떤 수의 제곱수만이 해당한다는 사실을 유도**&ZeroWidthSpace;해낼 수 있다.

---

문제 조건에서 N이 21억 이하, 즉 int 이내의 범위에서 나타난다는 것을 활용하여 21억의 제곱근을 먼저 구하고, 이 범위 내 제곱수를 모두 구해두자.
그런 뒤 주어지는 N이 모두 구해둔 제곱수의 어떤 범위 내부인지 보고 체크하면서 배열을 돌면서 N보다 커지는 시점에서 딱 끊어주고 그 이전까지의 개수를 출력한다.


## 코드화
### 제곱수 리스트 반환 메소드 - getSquareList
```JAVA
public static final int MAX_VALUE = 2100000000;
public static ArrayList<Integer> getSquareList() {
    ArrayList<Integer> squareNumList = new ArrayList<>();
    for(int i=1; i<=Math.sqrt(MAX_VALUE); i++)
        squareNumList.add(i*i);
    return squareNumList;
}
```
문제의 범위인 21억 이내의 수에 대하여 모든 제곱수를 저장한다.   
1부터 21억의 제곱근 값인 약 46,000에 대하여 돌면서 리스트에 이 값의 제곱수를 추가한 뒤, 리스트를 반환해준다.

### 메인 구조 - main
```JAVA
public static void main(String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    int N = Integer.parseInt(br.readLine()), cnt = 0;
    ArrayList<Integer> squareList = getSquareList();
    for(int i=0; i<squareList.size(); i++) {
        if(squareList.get(i) <= N) cnt++;
        else break;
    }
    System.out.println(cnt);
    br.close();
}
```

간단하다. 테스트케이스를 입력받아서 리스트를 인덱스 0부터 돌리면서 테스트케이스보다 작거나 같은 소수를 비교했다면 답에 1을 추가한다. 그러다가 최초로 테스트케이스보다 큰 소수가 나왔다면 그 이전까지의 개수가 바로 답이 된다.

## 정리

이 코드에 대하여 각각 부분은 다음과 같이 시간 복잡도가 구성된다.

1. 완전제곱수 반환 (`getSquareList` 함수)
모든 완전제곱수에 대하여 특정 N을 받아서 할 수도 있었기에, 그 N에 대하여 생각한다면 $$\sqrt{N}$$번 진행하게 되므로 $$O(\sqrt{N})$$
	- 물론 이때 N이 21억으로 한정되므로 46,000번 정도 시행된다.

2. 테스트 케이스 처리 (`getPrimeList` 함수)
배열을 돌면서 각 값이 N보다 작은지 찾는다. 최악의 경우라도 21억을 직접 받았을 때의 경우이므로 동일하게 $$O(\sqrt{N})$$

꽤나 합리적이고 효율적이다!
