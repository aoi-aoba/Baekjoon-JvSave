# 아이디어
애드 혹 문제는 발상을 잘 생각해보는 것이 중요하다.

## 문제 파악하기
논리학 교수가 칠판에 다음과 같은 내용을 적는다.
- 정확하게 a개의 말은 참이다.
- 정확하게 b개의 말은 참이다.
- 정확하게 c개의 말은 참이다.
...

다음과 같이 적은 것에 대하여 몇 개가 참인지 알아내야 한다고 했을 때, 입력으로 $a, b, c, \cdots$에 들어갈 정수들이 주어진다. 정확히는
- 첫째 줄에는 적은 말의 개수 $N$이 50 이하의 자연수로 주어진다.
- 둘째 줄에는 각 말에 있는 정수 $a, b, c, \cdots$가 50 이하의 음이 아닌 정수이다.

이때, 내용이 모순이면 -1을 출력하고 가능한 답이 여러가지라면 가장 큰 값을 출력한다.

## 방법 고안
각 문장은 정확히 $x$개의 문장이 참이라는 진술을 하고 있으므로, 이 문장 자체가 참이 되려면 이 문장을 포함한 실제로 참인 문장의 개수가 $x$여야 한다고 볼 수 있다. 즉, 어떤 문장에 숫자 $i$가 적혀 있다면, 전체 참인 문장의 개수 역시 $i$여야 한다. 여기서 논리적 모순이 없기 위해서는

> 정수 $i$에 대하여 $i$개의 문장에 "정확히 $i$개의 문장이 참이다"라고 적혀 있어야 한다.

라는 조건을 세울 수 있다. 어떤 숫자 $i$가 정확히 $i$번 등장해야 모순이 없으며, 그때 참이 되는 문장은 $i$이다. 그렇지 않은 경우는 모순이다.

## 보충 설명 -  답이 0인 경우와 모순인 경우
이 문제에서 많이 헷갈리는 부분은 모순과 그렇지 않은 것을 구분하기 위해서인데, 몇 가지 케이스를 생각해보자.

### 일반적으로 해결 가능한 경우
- 정확히 0개의 문장이 참이다.
- 정확히 1개의 문장이 참이다.

이 두 개의 문장에 대해서는 모순인가, 그렇지 않은가? "정확히 0개의 문장이 참이다"는 참일 수 없다. "정확히 0개의 문장이 참이다"라는 말에 대해서, 다음과 같이 생각해볼 수 있다.

(1) "정확히 0개의 문장이 참이다"가 참이라면, 이미 자신의 주장과 반대되는 참인 문장이 존재해버리므로 자기부정 모순이다.

(2) 그렇다고 거짓으로 만들어 버리면, (거짓 / 거짓)의 상황이므로 전체적으로 참은 0개이다. 그런데, 이는 결과적으로 우리가 '거짓'이라고 했던 "정확히 0개의 문장이 참이다"라는 말에 부합해버려, 자기부정 모순이다.

(3) 그렇다면 우선 "정확히 0개의 문장이 참이다."라는 말은 거짓이어야 함이 보장되기 때문에, "정확히 1개의 문장이 참이다."는 참이어야 한다. 만약 이 문장이 거짓이면 모두 다 거짓이므로 "정확히 0개의 문장이 참이다"라는 말이 정확히 부합하여 모순이 된다.

(4) 결과적으로 "정확히 1개의 문장이 참이다"가 참이라면 자기 자신이 참이면서 전체에서 1개만 참이기 때문에 논리적 오류가 없다.

코드를 짜고 나서 확인해보면 당연한 결과임을 알 수 있게 되긴 하다.

### 답이 0인 경우 (모순이 아님)
답이 0인데 모순이 아니라는 말이 이상하게 느껴질 수 있지만, 모두 거짓이면서 논리적 오류가 없을 수도 있다. 아래 두 문장을 보자.

- 정확히 1개의 문장이 참이다.
- 정확히 1개의 문장이 참이다.

모순인가, 그렇지 않은가? 이것도 하나하나 체크해보면 된다.

(1) 만약, "정확히 1개의 문장이 참이다"가 참이라면, 두 문장이 같기 때문에 둘 다 참이 되어 2개의 문장이 참이기 때문에 모순이다.

(2) 그러나, 둘 다 거짓이라면, 즉 정확히 0개의 문장이 참인 상태이므로 둘 다 거짓이고 이는 논리적 문제가 없다.

따라서 이런 경우에서는 0을 출력해서 '참인 문장이 없다'라고 표현하는 것이다. 답이 0인 경우임에도 모순이 아니라는 것을 유의해야 한다. 한 가지 더 살펴보자.

- 정확히 2개의 문장이 참이다.
- 정확히 3개의 문장이 참이다.
- 정확히 4개의 문장이 참이다.
- 정확히 3개의 문장이 참이다.

이 경우에도 모두 거짓이어야 한다는 것을 이해하겠는가? 여기에서 모순은 발생하지 않는다. 왜냐, 자기 자신만큼의 문장 개수를 똑같이 가져야만이 성립한다고 위의 '방법 고안'에서 설명했는데, $x=2$는 한 번 나왔고, $x=3$은 두 번 나왔으며, $x=4$는 한 번 나왔다. 여기에서부터 당장 참으로 성립할 수 있는 문장은 전혀 없으며, 그렇다고 해서 이들을 모두 거짓으로 돌린다고 해서 앞뒤가 안맞는 말이 되는 건 전혀 아니다. 그냥 참이 없는 문장들일 뿐이다. 그렇기 때문에 정확히 0개의 문장이 참인 상태이고, 답이 0인 것이다.

아래에서 확인하겠지만, 모순은 '그 어떤 경우로 참/거짓을 두어도 말이 앞뒤가 안맞는 경우'이다. 유의하자.

### 모순인 경우 (-1 출력)
여기서의 두 가지 케이스는 '모순'이다. 어떤 방법으로도 설명할 수 없다. 그걸 지켜보도록 하자.

- 정확히 0개의 문장이 참이다.
- 정확히 0개의 문장이 참이다.

이 두 문장이 모순이라는 것은 바로 알아볼 수 있었을 것이다. 위에서 설명했듯, "정확히 0개의 문장이 참이다"라는 문장은 자기모순 문장이다. 참/거짓을 어떻게 설정하든 이 두 문장을 완벽하게 해결할 수 있는 방법이 전혀 존재하지 않는다.

- 정확히 0개의 문장이 참이다.
- 정확히 2개의 문장이 참이다.

그러면 이 두 개의 문장에 대해서는 모순인가, 그렇지 않은가? 이것도 모순이다.

(1) "정확히 0개의 문장이 참이다"는 참일 수 없다. 위에서 말했지만 자기부정의 모순이다.

(2) 1)에서 이미 눈치챘겠지만, 이 문장은 이미 모순임이 드러났다. 자기부정 모순을 피하기 위해 첫 번째 문장을 거짓으로 만든 순간, 정확히 2개의 문장이 참일 수가 없다. 즉, 그러면 이 문장도 거짓이 되고, 전체에서 0개의 문장이 참이기 때문에 첫 번째 문장이 성립하여 모순이 된다.

## 코드화
```JAVA
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine()), res = -1;
        int[] arr = new int[51];
        Arrays.fill(arr, 0);
        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 0; i < N; i++)  {
            int x = Integer.parseInt(st.nextToken());
            arr[x]++;
        }
        for (int i = 0; i < 51; i++)
            if (i == arr[i]) res = i;
        System.out.println(res);
    }
}
```

여기에서 확인해야 하는 것은 딱 하나밖에 없다. 해당 숫자가 나온 횟수가 자기 자신과 같으면 된다. 의아하게 느껴질 수 있지만, 위의 예시를 잘 생각해보자.

- 일반적으로 해결되는 경우에서는 사실상 '방법 고안'에서 적어두었듯, 해당 문장을 포함하여 $x$개의 문장이 나와서 모두 참이 되어야 성립할 수 있다. 그러므로 0이 아닌 i에 대하여 해당 경우가 발생한다면 당연히 성립한다는 것은 자명하다.
- 동시에, 0이 0개였을 때는 자기모순 문장은 일단 없다는 것이다. 그런데, 모든 문장에 있는 숫자가 1 이상인 자연수임에도 자기 자신만큼 등장하지 않았다는 것은, 결과적으로 다 거짓이어야만이 성립할 수 있다는 것이다. 보충설명의 답이 0인 경우를 보면 알 수 있다. 모든 문장에 나오는 숫자가 0보다 큰데, 자기 자신만큼 해당 문장을 가지고 있지 않으니 성립할 수 있는 조건이 전혀 없다. 따라서 `arr[0]==0`인 경우도 기본적으로 참이다.
- 물론, 문제 조건에서 '가능한 답이 여러 가지이면 가장 큰 값을 출력'하라고 했기 때문에 가능한 일이다. 어떻게든 다른 문장이 참으로서 성립하게 된다면, 0을 출력할 일은 없기 때문이다.

## 정리
논리 문제가 말장난이 심해서 풀기 어렵다. 하지만 문제 자체를 푸는 코드는 간단하게 짤 수 있었다.
