# 아이디어
**회의실 배정 문제(Meeting Room Allocation Problem)**&ZeroWidthSpace;로서 잘 알려져 있는, 그리디 알고리즘의 대표적인 문제 중 하나이다.

## 문제 파악하기
한 개의 회의실이 있는데 이를 사용하고자 하는 $N$개의 회의에 대하여 회의실 사용표를 만들려고 한다. 각 회의 $I$에 대해 시작시간과 끝나는 시간이 주어져 있고, 각 회의가 겹치지 않게 하면서 회의실을 사용할 수 있는 회의의 최대 개수를 찾아보자. 단, 회의는 한번 시작하면 중간에 중단될 수 없으며 한 회의가 끝나는 것과 동시에 다음 회의가 시작될 수 있다. 회의의 시작시간과 끝나는 시간이 같을 수도 있다. 이 경우에는 시작하자마자 끝나는 것으로 생각하면 된다.

입력은 다음과 같이 주어진다:
- 첫째 줄에 회의 수 $N$이 10만 이하의 자연수로 주어진다.
- 둘째 줄부터 $N+1$번째 줄까지 각 회의 정보가 주어진다.
- 각 회의의 정보는 공백을 사이에 두고 회의 시작시간과 종료시간이 주어진다.
- 회의 시작시간과 종료시간은 $2^{31}-1$보다 작거나 같은 자연수 또는 $0$으로 주어진다.

## 방법 고안
정렬과 그리디 알고리즘이 '왜' 쓰여야 하는지, 어떻게 최적해를 보장하는지에 대한 생각이 필요하다.

### 어떻게 그리디 전략이 최적해를 보장할 수 있는가?
우선, 이 문제에서 회의가 `(start, end)`의 순서쌍으로 주어지며, 한 회의가 진행 중이면 다른 회의는 시작할 수 없고 가능한 한 많은 회의를 골라야 한다.

이때, 일반적으로 생각할 수 있는 아이디어 중 하나는, **종료 시각이 빠른 회의를 먼저 선택하는 것이 최적해를 만든다**&ZeroWidthSpace;라는 것이다. 종료 시각이 빠른 회의를 먼저 선택하면, 그 다음의 회의를 선택할 기회가 가장 많아진다. 즉, 가장 빨리 끝나는 활동을 선택하면, 이후 **남는 시간 동안 더 많은 활동의 배치가 가능하다**&ZeroWidthSpace;는 그리디 전략으로 볼 수 있는 것이다.

만약 이 방식이 최적해가 아니라고 해 보자. 즉, 어떤 Optimal(최적해)의 회의 선택 목록이 존재하며 우리가 고른 목록보다 회의 수가 더 많다고 가정하자. 근데 우리가 종료 시간이 가장 빠른 회의를 선택했다는 것은 결과적으로 **남은 시간 동안 가장 많은 회의를 선택할 기회를 제공하는 회의를 골랐다**&ZeroWidthSpace;는 의미이다. 그런데, 최적해가 별도로 있고 그 해가 우리가 선택한 것보다 늦게 끝나는 회의라면, 우리보다 **더 적은 수의 회의를 선택하게 됨**&ZeroWidthSpace;이 자명하다.

가령, 우리가 3이라는 시간에 끝나는 회의를 선택했고 이것이 종료 시간이 가장 빠르다고 해보자. 그런데 5라는 시간에 끝나는 회의가 최적해가 될 수 있을까? 불가능하다. 시간으로서 벌써 `3, 4, 5`에 시작하는 회의들을 고를 수 없다는 결론에 도착하고 **기회적으로도 최적이 아니다.** 그러므로 그리디 전략이 어떤 경우에서든 최적해가 될 수밖에 없고, 가정이 모순이 됨에 따라 최적해임이 자명하게 증명된다.

따라서, 탐욕적 선택 조건(Greedy Choice Property)과 부분 문제 최적 구조(Optimal Substructure)를 만족함에 따라 전체 최적해를 구성하는 데 문제가 없다.

### 이 방식을 그러면 어떻게 사용해야 하는가?
위에서 설명하였듯 종료 시각이 빠른 회의를 선택해야 하므로, 회의에 대한 정렬이 필요하다. 종료 시각을 기준으로 회의를 정렬한 다음에 가장 앞쪽에 온 종료 시각의 회의를 먼저 고른다.

```
11
1 4
3 5
0 6
5 7
3 8
5 9
6 10
8 11
8 12
2 13
12 14
```

예제 입력으로 주어진 이 회의들의 경우, 종료 시간을 기준으로 정렬되어 있음을 볼 수 있다. 그러면 맨 앞의 종료 시간인 `1 4` 회의를 먼저 고른다. 그러면 이 회의실은 `4`까지는 시간이 지나야 한다. 그러면 그 다음에 시작 시간이 `4` 이후이면서, 가장 빠른 종료 시간인 것은 `5 7`이다. 그 다음은 `8 11`이며, 그 다음은 `12 14`로서 맨 마지막 정렬된 회의에 도착함에 따라 4개의 회의를 진행할 수 있음을 고를 수 있게 된다.

> 결론적으로,   
> **종료 시각을 기준으로 정렬**한 뒤에 가장 빠른 종료 시간의 회의부터 선택한 다음, 그 회의 **종료 시간 혹은 그 이후에 시작하면서 가장 빠른 종료 시간인 회의**&ZeroWidthSpace;를 그때그때 바로 선택해준다.

---

이 점에 착안하여 코드를 짜면 되겠다.


## 코드화
### 입력 처리
```java
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int N = Integer.parseInt(br.readLine()), result = 1;
        int[][] tasks = new int[N][2];
        for (int i = 0; i < N; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            tasks[i][0] = Integer.parseInt(st.nextToken()); // 시작시간
            tasks[i][1] = Integer.parseInt(st.nextToken()); // 종료시간
        }
```

입력은 `StringTokenizer`를 활용하여 시작 시간 및 종료 시간을 크기 2의 배열에 담고, 이 배열들을 전체적으로 담기 위해 `task`를 2차원 배열로 설정해두었다.

### 정렬
```java
		...
        // 종료 시각을 기준으로 회의들을 정렬, 종료 시각이 같으면 시작 시간 기준으로 정렬
        Arrays.sort(tasks, new Comparator<int[]>() {
            @Override
            public int compare(int[] task1, int[] task2) {
                if (task1[1] == task2[1]) return Integer.compare(task1[0], task2[0]);
                else return Integer.compare(task1[1], task2[1]);
            }
        });
```

종료 시간을 기준으로 정렬하기 위해 `Arrays.sort()`를 사용하면서 `new Comparator<int[]>`를 정의, 새로운 규칙을 설정하였다. 종료 시각이 같으면 시작 시간을 기준으로 정렬한다. 

> 물론, 이 과정은 크게 문제가 되지 않는다. 시작 시간을 기준으로 정렬하지 않아도 어차피 선택하는 기준은 이전에 선택한 회의를 기준으로 하여 그 시간과 동일하거나 더 이후의 회의만 선택 가능하고 탐욕적 선택을 진행함과 동시에 종료 시간이 같다는 점에서 어차피 회의 개수에 영향을 주지 않는다.

### 최적해 선택 및 출력
```java
		...
        int end = tasks[0][1]; // 종료 시각이 가장 빠른 회의는 무조건 진행한다 (result가 1인 이유)
        for (int i = 1; i < N; i++) {
            if (end <= tasks[i][0]) {
                // 회의 종료 동시에 다음 회의 시작 가능이라 했으므로 end가 특정 회의 이하이면 됨
                end = tasks[i][1]; // 해당 회의 진행
                result++; // 회의 개수 증가
            }
        }

        bw.write(String.valueOf(result));
        bw.flush();
    }
}
```

위에서 설명한 대로 종료 시각이 가장 빠른 회의는 선택하여 무조건 진행한다. 그래서 맨 위에서 `result`의 변수 값을 1로 설정해두었다. 그리고, 회의 종료 동시에 다음 회의를 시작할 수 있다고 했기 때문에 `end <= tasks[i][0]`을 활용하였다. 모든 회의를 싹 `for`문으로 돌아보면서 그리디하게 선택한 다음, 선택했을 때는 그 회의를 진행했다는 의미로 `end`를 변경해주고 `result`를 1 증가시켜서 맨 마지막에 `result`를 출력해주면 되는 것이다.

## 정리
그리디 알고리즘은 최적해가 항상 보장된다고 설명하기 어렵다. 그래서 문제 내의 조건을 활용하여 최적해가 보장될 때 혹은 최적해를 보장할 방법이 있을 때 사용해야 한다. 그걸 파악하는 것을 생각하게 하는 좋은 문제였다.
