# 아이디어
시작점이 여러 개인 BFS 문제인 '토마토(BOJ 7576, G5)' 문제에서, 좌표축이 3차원으로 늘어났다. 풀이하는 로직은 같지만, 좌표축을 3차원으로 제작해주기만 하면 된다. 

## 문제 파악하기
![](https://velog.velcdn.com/images/aoi-aoba/post/a668772b-dec0-457e-b2da-eb4db522801f/image.png)

토마토를 보관하는 $M \times  N$ 크기의 격자 모양 상자를 $H$개 수직으로 쌓아서, 잘 익은 토마토와 아직 익지 않은 토마토를 섞어 보관한다. 그러면 **보관한 하루 뒤에는 익은 토마토에 인접한 익지 않은 토마토들이 익은 토마토의 영향을 받아 익게 된다.** 한 토마토의 인접한 곳은 **위, 아래, 왼쪽, 오른쪽, 앞, 뒤**&ZeroWidthSpace;에 위치한 토마토를 의미한다. 대각선의 토마토에는 영향을 주지 못하고, 토마토는 혼자 저절로 익지 않는다고 가정한다.

토마토를 창고에 보관하는 격자 모양의 상자들의 크기와 익은/익지 않은 토마토들의 정보가 주어지면, 며칠이 지나면 토마토가 모두 익는지 최소 일수를 구하는 프로그램을 작성하자. 단, 일부 칸에는 토마토가 들어있지 않을 수도 있으며, 토마토가 모두 익을 수 있는 경우라고 보장하지는 않는다.

---

입력은 다음과 같이 주어진다:
- 첫 줄에는 상자 크기를 나타내는 두 정수 $M, N$과 함께 쌓는 상자의 수 $H$가 주어진다. 이들은 각각 가로 칸의 수와 세로 칸의 수, 그리고 높이이며, $2 ≤ M ≤ 100, 2 ≤ N ≤ 100, 1 ≤ H ≤ 100$의 범위로 주어진다.
- 둘째 줄부터는 가장 밑의 상자부터 가장 위의 상자까지 저장된 토마토의 정보가 주어진다. 즉, $N$개 줄에 걸쳐 하나의 상자에 저장된 토마토들의 정보가 주어진다. 한 줄에는 $M$개의 토마토 상태가 주어진다. 그 $N$개 줄이 총 $H$번 반복하여 주어진다.
- 토마토의 상태는 1이 익은 토마토, 0이 익지 않은 토마토이며, -1은 토마토가 들어있지 않은 칸을 의미한다.
- 토마토는 꼭 하나 이상 있는 경우가 입력으로 주어짐이 보장된다.

출력은 토마토가 모두 익을 때까지의 최소 날짜를 출력해야 한다. 이미 입력부터 토마토가 모두 익어있다면 0, 토마토가 모두 익을 수 없다면 -1을 출력하자.

## 방법 고안
'최단거리'를 찾아야 하기 때문에 BFS가 적절하다. 다만, 여기서는 BFS의 처리에 관련된 이야기를 하려고 한다. 앞의 두 개에서는 이전 연계 문제로서 2차원 배열만 감안하면 되었던 '토마토(BOJ 7576, G5)'의 문제 설명이며, 맨 마지막에 3차원에 대한 이야기를 하려고 한다.

### 익은 토마토가 한 곳이 아니다
미로 찾기 같은 방식은 한 곳을 중심으로 하여 퍼져나가며 검색하는 방식이었다면, 여기서는 익은 여러 개의 토마토가 임의적으로 배치되어 이들로부터 동시에 퍼져 나가야 하는 구조이다. 그렇기 때문에, 각각의 위치를 중심으로 하여 BFS를 운영해 나가야 하는 것이 포인트이다.

그렇기 때문에, 리스트를 통해 익은 토마토의 좌표를 따로 저장하거나 BFS를 위해 만든 큐 구조에 아예 초반의 시작해야 하는 지점의 익은 토마토의 좌표를 저장하는 방법을 사용하면 초반에는 익은 토마토 최초 좌표들을 중심으로 dx-dy를 돌릴 것이고, 그렇게 돌려서 1일 뒤에 익게 되는 부분은 입력에서 주어진 익은 토마토들의 이후로 들어가게 되어 선입선출 원칙에 의해 나중에 나올 것이다. 그렇게 한다면, 토마토 하나하나에 대해 $n$일차를 천천히 나아갈 수 있기 때문에, 어떤 토마토의 진행 상황을 먼저 살피게 되거나 하는 불상사는 일어나지 않을 것이다.

### 방문 여부를 나타낼 필요는 없다
일반적으로 BFS의 성능을 높이기 위해서, 혹은 헷갈리지 않기 위해서 메인 맵을 받아오는 2차원 배열과, 방문 여부를 나타내는 2차원 배열(대부분 `visited[][]`로 구현한다)을 각각 구현하는데, 이 경우에서는 오히려 그게 더 불리하다. 메모리 사용량도 많지만, 당장 토마토가 없는 부분은 굳이 방문할 필요가 없다. 이미 본 곳도 방문할 필요가 없다. 그렇다면, 이미 본 곳에는 해당 토마토가 몇 일차에 익게 되는지 숫자를 저장하자. 그리고 나머지는 그대로 입력 상태로 두는 것이다.

그렇게 한다면, 토마토가 없는 곳은 -1 값을 가지고, 익은 토마토는 1 이상의 값을 가진다. (초기 입력 조건에서의 익은 토마토는 1이다) 그렇기 때문에 우리는 그저 한 개의 `int[][]` 2차원 배열에 대하여 값이 0인 곳만 순회하면서 BFS를 운영하면 된다는 결론에 이르게 된다. 그렇게 한다면 배열을 여러 개 만들어서 메모리 낭비를 하지 않아도 되겠다.

### 높이를 감안하여 3차원을 생각해야 한다
2차원 배열은 가로-세로의 한 상자를 기준으로 하기 때문에 dx-dy로 움직일 수 있지만, 우리가 생각해야 하는 것은 위아래로 쌓인 z축마저 고려해야 한다. 그렇기 때문에 dx-dy-dz의 구조로 움직여야 하는데, 크게 어렵진 않다.

```java
public static int[] dx = {-1, 1, 0, 0};
public static int[] dy = {0, 0, -1, 1};

...
for (int i = 0; i < 4; i++) {
	int nx = x + dx[i], ny = y + dy[i];
    // 대략 범위 체크를 위한 if문 들어옴
}
```
dx-dy를 구현하기 위해서는 다음과 같이 진행하는데, 여기에서 중요한 것은 x축이나 y축으로 한 칸 움직일 때 다른 별개의 축은 움직이지 않아야만 '인접한 칸'으로 이동한다는 점이다. 그렇다면, dz 역시 똑같이 감안해주면 되는 것이다. dz가 움직일 때는 dx-dy의 변화치는 0이어야 한다.

```java
public static int[] dx = {-1, 1, 0, 0, 0, 0};
public static int[] dy = {0, 0, -1, 1, 0, 0};
public static int[] dz = {0, 0, 0, 0, -1, 1};

...
for (int i = 0; i < 6; i++) {
	int nx = x + dx[i], ny = y + dy[i], nz = z + dz[i];
    // 대략 범위 체크를 위한 if문 들어옴
}
```

---

## 코드화
### BFS를 활용하기 위한 메소드 구조
```java
public class Main {
    public static int M, N, H, checked = 0, result = 0;
    public static int[] dx = {-1, 1, 0, 0, 0, 0};
    public static int[] dy = {0, 0, -1, 1, 0, 0};
    public static int[] dz = {0, 0, 0, 0, -1, 1};
    public static int[][][] board;
    public static Queue<int[]> Q = new ArrayDeque<>();

    public static void bfs() {
        while (!Q.isEmpty() && checked < M * N * H) {
            int[] cur = Q.poll();
            int x = cur[0], y = cur[1], z = cur[2], d = cur[3];

            for (int i = 0; i < 6; i++) {
                int nx = x + dx[i], ny = y + dy[i], nz = z + dz[i];
                if (nx >= 0 && nx < M && ny >= 0 && ny < N && nz >= 0 && nz < H && board[nz][ny][nx] == 0) {
                    Q.offer(new int[] {nx, ny, nz, d + 1});
                    board[nz][ny][nx] = d + 1;
                    result = Math.max(result, d + 1);
                    checked++;
                }
            }
        }
    }
```

`int[][][]` 3차원 배열 `board`는 방문 여부, 토마토의 익음 여부, 그리고 토마토의 존재 여부 및 토마토가 익는 시기까지 모두 입력해두는 배열이다. dx-dy-dz를 돌아볼 수 있게 배열을 지정하고, 크기 $M$과 $N$과 높이 $H$ 역시 모두 전역으로 설정했다. `checked`는 모든 격자에 대하여 체크한 부분이 몇 곳인지 확인하는 변수이다. `result`는 답인, 토마토가 익는 데 걸리는 최소한의 날짜를 저장한다. Queue `Q` 역시 전역 선언했다.

`bfs` 알고리즘은 다음과 같이 구현한다.
- `bfs()`의 시작 지점이 특별히 없으므로, parameter는 두지 않았다. `Q`라는 큐 구조 안에 존재하는 값을 받아오면서 동시에 `checked` 즉 확인한 칸 개수가 모든 격자 개수보다 적을 때만 순회한다.
- Queue에서 좌표를 하나씩 꺼내어 순회한다. 이 지점을 각각 `x`, `y`, `z`라는 변수에 좌표를 지정한다. 그 토마토에 도달하는 때까지 걸리는 시간은 `d`라는 변수에 지정한다. 그리고 for 문을 이용해 이동한 `nx`, `ny`, `nz`의 값을 구한다.
- 해당 값이 '범위 내에 존재'하는지, 그리고 '익지 않았고 이미 확인한 적 없는 토마토(즉, 값이 0인 토마토)'인지 체크한 다음, 만약 그게 모두 맞다면 Queue에서 이후에 살펴볼 곳으로 추가하고 `d + 1`로 해당 토마토가 익을 시간을 지정하여 저장한다. `result`는 `d + 1`과 최댓값을 비교하여 넣어주며, 한 개의 토마토를 더 체크한 것이므로 `checked`를 1 늘려준다.

### main 메소드
```java
	...
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        StringTokenizer st = new StringTokenizer(br.readLine());
        M = Integer.parseInt(st.nextToken());
        N = Integer.parseInt(st.nextToken());
        H = Integer.parseInt(st.nextToken());

        board = new int[H][N][M]; // z-y-x

        for (int i = 0; i < H; i++) {
            for (int j = 0; j < N; j++) {
                st = new StringTokenizer(br.readLine());
                for (int k = 0; k < M; k++) {
                    board[i][j][k] = Integer.parseInt(st.nextToken());
                    if (board[i][j][k] == -1) checked++;
                    else if (board[i][j][k] == 1) {
                        Q.offer(new int[]{k, j, i, 0});
                        checked++;
                    }
                }
            }
        }

        bfs();
        System.out.println(checked == M * N * H ? result : -1);
    }
}
```
초반 입력을 받아서 저장하는 것은 별반 문제가 되지 않으나, 3중 for 문 내부에서 하는 일이 조금 다르다.

- 입력 과정에서 우선 각 토마토의 정보를 받아 `board`의 위치에 저장한다.
- 이때, 만약 토마토가 없는 곳이라면 (-1의 값이라면) 이 곳은 돌 필요가 없다. 그러므로 `checked`를 1 늘리자. BFS로 돌지 않을 곳이므로 자명하게 이미 알고 있다는 의미인 것이다.
- 그리고, 굳이 리스트를 만들어서 다시 옮기지 않기 위해 토마토가 이미 익어 있는 BFS의 시작점을 바로 전역 선언된 Queue에 모두 저장해둔다. 동시에 이 부분은 이미 알고 있다는 의미이므로 여기도 마찬가지로 `checked`를 1 늘려둔다.

그 뒤, `bfs()`를 호출하여 순회하고 나면 어떤 의미로든 종료될 것이다. 그때, `checked`의 값이 격자의 개수($N \times M \times H$)와 동일하면 모든 칸을 순회했다는 것이므로 (토마토가 없는 곳이나 이미 익은 토마토까지 모두 확인했다는 것이므로) `result`에 저장된 값을 출력하며, 그렇지 않으면 격자를 모두 체크하지 못했고 도달하지 않은 공간이 있다는 것이므로 `-1`을 출력하면 된다.
