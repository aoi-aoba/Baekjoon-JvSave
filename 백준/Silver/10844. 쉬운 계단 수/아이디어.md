# 아이디어
전형적인 다이나믹 프로그래밍 문제

## 문제 파악하기
계단 수는 인접한 모든 자리의 차이가 1인 수를 의미한다. 787, 45656 등이 이에 해당한다. $N$이 주어지면, 길이가 $N$인 계단 수가 총 몇 개인지 구해야 한다.
- 첫째 줄에 입력으로 $N$이 주어지며, 100 이하의 자연수이다.
- 0으로 시작하는 수는 계단수가 아니다.
- 1,000,000,000으로 나눈 나머지를 출력한다.

## 방법 고안
다이나믹 프로그래밍 방식으로 구현할 수 있겠다고 생각했는데, 2차원 DP 테이블을 만들면 쉽게 풀 수 있다. 내 방식은 이러하다:

먼저, 그냥 간단히 생각해보자. $N = 1$이 아니라면 어떻게든 자신과 인접한 위치로 향해야 한다. 1은 0과 2가 있고, 2는 1과 3, 3은 2와 4, ..., 그리고 8은 9와 7, 9는 8, 0은 1만 가능하다. 그러면, 우리는 이 계단 수를 계속 쌓아가면 된다는 것이다.

$N=2$일 때 가령 10, 12, 21, 23, 32, 34, ... 와 같이 진행된다고 했으면, 우리는 결과적으로 항상 일의 자리만 지켜보고 그 뒤에 $N=2$를 시행하는 것처럼 뒤를 이어주면 $N=3, 4, \cdots$와 같은 경우도 구현할 수 있는 것이다.

그렇기에 DP 테이블을 2차원 배열로 구현하여 dp[N이 몇일 때]\[일의자리가 몇인 개수]로 해서 제작해두면, `dp[N][1] = dp[N-1][2] + dp[N-1][0]` 과 같은 방식으로 이전 단계에서의 관계성을 가져와 바로 이어주면 된다. 결국 매 순간에서의 특정 일의 자리가 발생하는 개수를 체크해 그 뒤에는 이 숫자가 이어질 수밖에 없다는 인접성을 이용하여 풀어주면 된다고 설명할 수 있겠다.

잘 이해가 되지 않으면, 코드를 보는게 빠르다.

## 코드화
```JAVA
public class Main {
    public static int[][] dp;
    public static int dp(int N) {
        if(N == 1) return 9;
        dp = new int[N+1][10];
        dp[1][0] = 0;
        Arrays.fill(dp[1], 1, 10,1);
        for (int i = 2; i <= N; i++)
            for (int j = 0; j <= 9; j++)
                dp[i][j] = switch (j) {
                    case 1 -> (dp[i-1][2] + dp[i-1][0]) % 1000000000;
                    case 2 -> (dp[i-1][3] + dp[i-1][1]) % 1000000000;
                    case 3 -> (dp[i-1][4] + dp[i-1][2]) % 1000000000;
                    case 4 -> (dp[i-1][5] + dp[i-1][3]) % 1000000000;
                    case 5 -> (dp[i-1][6] + dp[i-1][4]) % 1000000000;
                    case 6 -> (dp[i-1][7] + dp[i-1][5]) % 1000000000;
                    case 7 -> (dp[i-1][8] + dp[i-1][6]) % 1000000000;
                    case 8 -> (dp[i-1][9] + dp[i-1][7]) % 1000000000;
                    case 9 -> dp[i-1][8] % 1000000000;
                    case 0 -> dp[i-1][1] % 1000000000;
                    default -> 0;
                };
        long res = 0;
        for (int i = 0; i < 10; i++) {
            res += dp[N][i];
        }
        return (int)(res % 1000000000L);
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int N = Integer.parseInt(br.readLine());
        System.out.println(dp(N));
        br.close();
    }
}
```

설명이 애매했을 뿐 결과적으로 같은 이야기다.   
$N=1$일 때는 일의 자리가 0~9일 때 각각 한 가지만이 존재한다. 하지만 그 이후부터는 $N=2$일 때는, 두 자리 수 중 2로 끝나는 것은 그 전에 숫자가 인접해야 하므로 12, 32의 두가지인데 이는 이전이 '1' 또는 '3'으로 끝났어야 하므로 `case 2 -> (dp[i-1][3] + dp[i-1][1]) % 1000000000;`와 같은 방식으로 코드가 구현되는 것이다.   
물론, 여기에서 포인트 중 하나는 결과적으로는 이 값들이 매우 크기 때문에 `long`을 아예 도입해버려서 맨 마지막 나머지 계산 후 `int` 형으로 바꾸는 것이고, 무엇보다 모듈러 연산에서의 특성을 고려하여 각 `case` 에서도 모듈러 연산을 하고 그들의 합을 구한 뒤에도 모듈러 연산을 해야한다는 점이다.   
이는 당장 올바른 값을 구하는 데에도 필요하지만 불필요하게 계산값이 너무 커져서 `long`을 초과해버리거나 하는 경우를 방지하는 데에도 중요하다.

## 정리
코드 내에서 핵심적인 반복문은 `dp(int N)` 메소드에서의 이중 for 문이고, 바깥 루프는 $O(N)$이며 안쪽 루프는 상수 횟수로 반복되기 때문에 결과적으로는 시간 복잡도 $O(N)$, 공간 복잡도 $O(N)$으로 해결할 수 있다.
