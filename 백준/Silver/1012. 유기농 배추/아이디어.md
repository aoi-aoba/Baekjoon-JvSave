# 아이디어
DFS 혹은 BFS를 활용하여 전체를 돌면 되는데... 문제는 '배추'의 위치가 중요하다!

## 문제 파악하기

유기농 배추의 재배를 위해 해충 방지에 효과적인 배추흰지렁이를 최소한으로 두려고 한다. 배추흰지렁이는 배추 근처에 서식하며 해충을 잡아먹는데, 어떤 배추에 한 마리라도 살고 있으면 인접한 다른 배추로 이동이 가능하기 때문에 그 배추들도 해충으로부터 보호받을 수 있다. 한 배추의 상하좌우 네 방향에 다른 배추가 위치하면 서로 인접해있다고 한다.

땅이 고르지 못한 탓에 배추가 군데군데 심어져 있는데, 인접한 배추들이 몇 군데에 퍼져있는지 조사하여 최소한의 배추흰지렁이를 둘 수 있게 해 보자.

<table class="table table-bordered" style="width:40%">
	<tbody>
		<tr>
			<td style="text-align:center; width:4%"><strong>1</strong></td>
			<td style="text-align:center; width:4%"><strong>1</strong></td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
		</tr>
		<tr>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%"><strong>1</strong></td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
		</tr>
		<tr>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%"><strong>1</strong></td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
		</tr>
		<tr>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%"><strong>1</strong></td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
		</tr>
		<tr>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%"><strong>1</strong></td>
			<td style="text-align:center; width:4%"><strong>1</strong></td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%"><strong>1</strong></td>
			<td style="text-align:center; width:4%"><strong>1</strong></td>
			<td style="text-align:center; width:4%"><strong>1</strong></td>
		</tr>
		<tr>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%"><strong>1</strong></td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%">0</td>
			<td style="text-align:center; width:4%"><strong>1</strong></td>
			<td style="text-align:center; width:4%"><strong>1</strong></td>
			<td style="text-align:center; width:4%"><strong>1</strong></td>
		</tr>
	</tbody>
</table>

위의 표처럼 주어진다면, 0은 배추가 안 심어진 땅이고 1은 배추가 심어진 땅이므로 총 5마리의 배추흰지렁이가 최소한으로 필요하다는 것을 알 수 있다.

---

입력은 다음과 같이 주어진다:
- 첫 번째 줄에는 테스트케이스 개수 $T$가 주어진다.
- 다음 줄부터 각각의 테스트케이스에 대해 첫째 줄에는 배추밭의 가로길이 $M$이 50 이하의 자연수로, 세로길이 $N$이 50 이하의 자연수로, 배추가 심어진 위치 $K$가 2500 이하의 자연수로 주어진다.
- 각각의 테스트 케이스의 첫 줄 다음 $K$개의 줄에 배추의 위치 $X$와 $Y$가 주어진다. 이들은 각각 $0 ≤ X ≤ M-1$ 및 $0 ≤ Y ≤ N-1$의 범위를 만족한다.

출력은 각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리 수를 한 줄에 하나씩 출력한다.

## 방법 고안
BFS나 DFS를 사용하여 지도를 돌아보는 것이 중요하다.

### 이차원 배열의 순회
이차원 배열을 순회하는 방법은 아무래도 이중 for 문으로 도는 것이지만, 여기에서는 인접한 '단지'를 구분하는 동시에 돌아야 한다는 것이 중요하다. 

어느 지점을 기준으로 하여, 주변의 단지를 판단하려면 어떻게 해야 할까? 상하 혹은 좌우로 인접해야 단지이기 때문에 우리는 해당 좌표를 $(x, y)$라고 두었을 때 $(x-1, y)$, $(x, y-1)$, $(x+1, y)$, $(x, y+1)$을 둘어봐야 한다는 것을 알 수 있다. `dx[]` 및 `dy[]`의 배열을 통하여 $x$와 $y$의 변화값을 저장하고 순회하는 방식으로 확인해보도록 할 수 있겠다. (dx-dy technique라고도 불린다)

### 너비 우선 탐색과 깊이 우선 탐색
우선, BFS에 대하여 생각해보자. 너비 우선 탐색은 그래프 상에서도 한 정점으로부터 나아갈 수 있는 다른 정점을 모두 생각해보고, 그것을 차례차례 순회하는 방식이었다. 그렇다면, 네 개 방향(상하좌우)에 위치한 곳을 각각의 정점으로 간주한다면 비슷한 방식으로 순회가 가능할 것이다. **즉 Queue 구조를 활용하여 순회하는 것을 사용**&ZeroWidthSpace;한다면 일반적인 BFS를 사용하는 것과 동일하게 풀 수 있을 것이다.

DFS는 어떨까? 깊이 우선 탐색은 그래프 상에서, 한 정점으로부터 나아갈 수 있는 대로 쭉쭉 뻗어나가서 더 이상 나아갈 수 없으면 다시 돌아오는 방식을 택한다. 그러면, 어떤 한 지점에 대하여 계속 dx-dy technique를 사용하여 **나아갈 수 있는 인접한 단지로 계속 뻗어나가 더 이상 그것이 네 개 방향 어디로도 불가능한 상황**&ZeroWidthSpace;까지 나아가면 한 개의 단지를 찾을 수 있을 것이다. **방문한 곳을 다시 가지 않아도 된다는 점**&ZeroWidthSpace;에서 이 반복이 끝나는 지점은 명료하다.

![](https://velog.velcdn.com/images/aoi-aoba/post/e4960e94-8842-4544-86de-de0c742828ee/image.png)

즉, 너비 우선 탐색은 위의 그림처럼 각 위치에 대하여 갈 수 있는 모든 경로를 Queue 구조를 활용하여 그래프에서의 알고리즘 분석처럼 뻗어나가는 모양이 그려지고, 깊이 우선 탐색의 경우는 한 위치에서 갈 수 있는 곳을 계속 쭉 넘어가다가 더 이상 갈 수 없으면 재귀 함수처럼 뒤로 다시 돌아가 쭉쭉 뻗어나가는 방식으로 넘어가면 된다.

### 좌표의 형태로 주어지는 배추를 돌기
여기에서 우리가 전체 배추밭을 돌 필요는 없다. '배추의 위치'가 주어지고 있기 때문에 그것을 위주로 도는 것이 중요하다. 사실상, 배추가 인접한 구역에 위치하여 있다면 DFS 혹은 BFS로서 그 구역에 인접한 배추임을 확인하고 알고리즘의 시작으로서 그 위치를 돌지 않게 하면 될 뿐, 굳이 그 외의 자명하게 배추가 없다는 위치를 for 문으로 돌면서 불필요한 시간을 늘릴 필요는 없다. 그러므로, 배추의 위치들만 확인하면서 이미 이전 배추의 위치로서 인접하게 위치한 배추여서 확인했는지 아닌지를 체크하고 체크한 적 없는 배추라면 새로운 구역에 위치한 것이므로 DFS나 BFS로 넘겨주면 되겠다.

---

이와 같은 방식으로 코드를 구현하면 되겠다. 아래에서는 BFS와 DFS의 코드를 모두 구현해보려고 한다.

## 코드화
### BFS를 활용하기 위한 메소드 구조
```java
public class Main {
    public static boolean[][] map, check;
    public static List<int[]> baechu;
    public static int[] dx = {0, 0, -1, 1};
    public static int[] dy = {-1, 1, 0, 0};
    public static int m, n, k, worms = 0;

    public static void bfs(int startX, int startY) {
        Queue<int[]> Q = new ArrayDeque<>();
        Q.offer(new int[]{startX, startY});

        while (!Q.isEmpty()) {
            int[] cur = Q.poll();
            int x = cur[0], y = cur[1];

            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i], ny = y + dy[i];
                if (nx >= 0 && nx < m && ny >= 0 && ny < n && map[ny][nx] && !check[ny][nx]) {
                    check[ny][nx] = true;
                    Q.offer(new int[]{nx, ny});
                }
            }
        }
    }
```

배추가 있는지 없는지를 표현하기 위한 `map[][]`의 2차원 배열 및 이미 확인한 곳은 `check[][]`의 2차원 배열에 저장한다. 둘 다 `boolean[]` 배열이면 충분하다. 그리고, 배추의 위치를 받아올 `List<int[]>`도 선언해둔다. dx-dy를 돌아볼 수 있게 배열을 지정하고, 크기 $m$과 $n$, 그리고 배추 개수 $k$, 지렁이 마리 수를 담을 `worms`변수까지 모두 전역으로 설정했다.

일반적인 `bfs` 알고리즘과 비슷한 방식으로 돌 수 있다.
- `bfs(int startX, int startY)`의 형태로 parameter로 주어지는 최초 시작 지점을 기준으로 Queue를 만들어서 이 안에 최초 지점을 삽입한다.
- Queue가 `isEmpty()`를 통해 비어있지 않은 동안, 좌표를 하나씩 꺼내어 순회한다. 이 지점을 각각 `x`, `y`라는 변수에 좌표를 지정한다. 그리고 for 문을 이용해 이동한 `nx`, `ny`의 값을 구한다.
- 해당 값이 '범위 내에 존재'하는지, 그리고 배추가 있는 곳인지, 그리고 이미 본 곳은 아닌지 체크한 다음, 만약 그게 모두 맞다면 `true`로 바꾸고 Queue에서 살펴볼 곳으로 값을 뒤에 추가한다.
- 앞에서부터 값을 계속 돌면서 체크하면 된다.

여기서는 각 구역의 개수만 체크하면 되기 때문에 굳이 `return`해줄 값이나 행동해줄 것은 별도로 없다.

### DFS를 활용하기 위한 메소드 구조
```java
public class Main {
    public static boolean[][] map, check;
    public static List<int[]> baechu;
    public static int[] dx = {0, 0, -1, 1};
    public static int[] dy = {-1, 1, 0, 0};
    public static int m, n, k, worms = 0;

    public static void dfs(int startX, int startY) {
        check[startY][startX] = true;
        for (int i = 0; i < 4; i++) {
            int nx = startX + dx[i], ny = startY + dy[i];
            if (nx >= 0 && nx < m && ny >= 0 && ny < n && map[ny][nx] && !check[ny][nx]) {
                dfs(nx, ny);
            }
        }
    }
```

위쪽에서 전역으로 선언하는 것은 BFS와 같다. 일반적인 `dfs` 알고리즘과 비슷한 방식으로 돌 수 있다.
- `dfs(int startX, int startY)`의 형태로  parameter로 주어지는 최초 시작 지점을 기준으로 `check[startY][startX]`를 확인했다고 `true`로 변경한다.
- 그리고, 위에서 사용했듯 네 개 방향의 지점을 확인하고, 만약 조건이 맞다면 바로 해당 지점으로 이동해버린다.
- 이런 방식으로 나아가다가 도중에 막히는 곳이 발생한다면 재귀를 역으로 돌아오면서 더 나아갈 수 있는 지점이 있었는지 for 문을 통해 확인하는 백트래킹과 유사한 과정을 거칠 것이므로 전체 구역을 돌 수 있게 된다.

### BFS와 DFS의 main 메소드
```java
	...
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringBuilder sb = new StringBuilder();

        int T = Integer.parseInt(br.readLine());
        while (T-- > 0) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            m = Integer.parseInt(st.nextToken());
            n = Integer.parseInt(st.nextToken());
            k = Integer.parseInt(st.nextToken());

            map = new boolean[n][m];
            check = new boolean[n][m];
            baechu = new ArrayList<>();

            for (int i = 0; i < k; i++) {
                st = new StringTokenizer(br.readLine());
                int x = Integer.parseInt(st.nextToken()), y = Integer.parseInt(st.nextToken());
                // 입력은 x-y 좌표축으로 주어짐
                baechu.add(new int[]{x, y});
                map[y][x] = true;
            }

            for (int i = 0; i < k; i++) {
                if (!check[baechu.get(i)[1]][baechu.get(i)[0]]) {
                    dfs(baechu.get(i)[0], baechu.get(i)[1]);
                    // bfs(baechu.get(i)[0], baechu.get(i)[1]);
                    worms++;
                }
            }

            sb.append(worms).append("\n");
            worms = 0;
        }

        bw.write(sb.toString());
        bw.flush();
    }
}
```
메인 메소드 부분은 모두 같다. 각각의 테스트케이스에 대하여 값을 받아오고, `map[][]`, `check[][]`의 이차원 배열과 `baechu` 리스트를 초기화한다.

입력으로 주어지는 배추 위치는 x-y의 좌표계 형태로 주어지기 때문에 배열에서는 뒤집어야 하는 것을 유의하고, 리스트에 추가하면서 배추가 있다는 표시를 `map`에 진행해준다. 그리고, 이 배추의 리스트를 돌면서 해당 배추의 위치가 이미 `dfs` 혹은 `bfs`에 의하여 확인한 곳은 아닌지 if문을 통해 확인한 뒤 아니라면 메소드 호출해준 다음 `worms++`로 한 구역을 추가해준다.

테스트케이스가 종료될 때마다 `StringBuilder`에 값을 `append`해주고, `worms`를 0으로 초기화해준 뒤, 맨 마지막에 일괄출력한다.

## 정리
재귀 깊이가 깊으면 스택 오버플로우의 위험을 가지는 DFS (Java는 특히 1,000~10,000 깊이에서 위험하다) 구조는 구현이 간단하고 직관적이다. 반면, BFS는 DFS에 비해 구현이 어렵지만 큐를 사용하기 때문에 재귀 깊이 문제가 발생하지 않으며 같은 레벨(거리)를 순회하는 것에 유리하다.
