# 아이디어
DFS(깊이 우선 탐색) 알고리즘을 직접 구현해서 풀면 된다.

## 문제 파악하기
$N$개 정점과 $M$개 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터 $N$번이고 모든 간선의 가중치는 1이다. 정점 $R$에서 시작하여 깊이 우선 탐색으로 노드를 방문할 경우 노드의 방문 순서를 출력하자. 깊이 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 **내림차순**&ZeroWidthSpace;으로 방문한다.

```
dfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점
    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.
    for each x ∈ E(R)  # E(R) : 정점 R의 인접 정점 집합.(정점 번호를 내림차순으로 방문한다)
        if (visited[x] = NO) then dfs(V, E, x);
}
```

---

입력은 다음과 같이 주어진다:
- 첫째 줄에 정점 수 $N$, 간선 수 $M$, 시작 정점 $R$이 주어진다.
- $N$은 5 이상 10만 이하의 자연수, $M$은 20만 이하의 자연수, $R$은 $N$ 이하의 자연수로 주어진다.
- 다음 $M$개 줄에 간선 정보 $u$ $v$가 주어지고, 이는 정점 $u$와 $v$의 가중치 1인 양방향 간선을 의미하며 $u$와 $v$는 서로 같지 않고, 항상 $u < v$이면서 모든 간선의 쌍 값이 다름이 자명하다.

출력은 첫째 줄부터 $N$개 줄에 대해 정수를 한 개씩 출력하는데, $i$번째 줄에는 정점 $i$를 방문하는 순서를 출력한다. 시작 정점의 방문 순서는 1이며, 방문 불가한 경우 0을 출력한다.

## 방법 고안
DFS 코드를 직접 구현해보는 데 의미를 가지는 문제이다. 의사 코드도 주어져 있고 DFS 알고리즘을 정말 구현해보는 것 자체가 문제이기 때문에 특별히 설명할 건 없다.

## 코드화
### DFS 로직
```java
public class Main {
    public static List<List<Integer>> graph = new ArrayList<>();
    public static boolean[] visited;
    public static int[] visitNumArr;
    public static int depth = 0;

    public static void dfs(int startNode) {
        visited[startNode] = true;
        depth++;
        visitNumArr[startNode] = depth;

        for (int node : graph.get(startNode))
            if (!visited[node]) dfs(node);
    }
```

각각의 노드에 대해 갈 수 있는 모든 노드를 `List<Integer>`로 저장하여 그래프는 `List<List<Integer>>` 형태로 저장된다. 방문한 곳을 다시 방문하지 않기 위하여 `boolean[] visited` 배열을 만들어주었고, `int[] visitNumArr`을 만들어 몇 번째 방문했는지 저장한다. `depth`는 방문하는 순서를 저장하는 변수이다.

`dfs` 로직은 다음과 같이 진행한다.
- `visited[]` 배열에서 해당 `startNode`를 방문했다고 `true`로 기록하고, `depth`를 1 증가시켜 `visitNumArr[]` 배열에서 해당 노드를 방문한 순서를 기록한다.
- 해당 노드에 대하여 방문할 수 있는 이웃 노드들을 가져온다. `graph.get(startNode)`의 형태로 받아오면 그 리스트를 enhanced-for Loop를 활용하여 하나씩 확인하고, 방문하지 않은 곳이라면 `dfs(node)`를 통해 재귀호출하여 방문한다.

### main 메소드
```java
	...
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringBuilder sb = new StringBuilder();

        StringTokenizer st = new StringTokenizer(br.readLine());
        int node = Integer.parseInt(st.nextToken());
        int line = Integer.parseInt(st.nextToken());
        int startNode = Integer.parseInt(st.nextToken());

        visited = new boolean[node + 1];
        visitNumArr = new int[node + 1];

        for (int i = 0; i <= node; i++)
            graph.add(new ArrayList<Integer>());

        for (int i = 0; i < line; i++) {
            st = new StringTokenizer(br.readLine());
            int node1 = Integer.parseInt(st.nextToken()), node2 = Integer.parseInt(st.nextToken());
            graph.get(node1).add(node2);
            graph.get(node2).add(node1);
        }

        for (int i = 0; i <= node; i++)
            graph.get(i).sort(Collections.reverseOrder());

        dfs(startNode);
        for (int i = 1; i <= node; i++)
            sb.append(visitNumArr[i]).append("\n");
        bw.write(sb.toString());
        bw.flush();
    }
}
```

이제 할 일은 각각의 값을 받아 DFS를 돌리기만 하면 된다.
- `node`와 `line`은 각각 정점과 간선의 개수이며, `startNode`를 통해 시작 정점 번호를 저장한다.
- `visited`와 `visitNumArr` 두 배열에 대해서는 0번의 인덱스를 사용하지 않기 때문에 `node+1`의 크기를 가져야 1번부터 번호를 매길 수 있다.

0번 인덱스는 사용하지 않는다고 하였기 때문에 `node` 번호까지 for 문을 돌려서 그래프 기반을 마련하고, `line`의 개수만큼 for 문을 돌려서 각각의 간선을 모두 추가해준다. 이때, 네트워크 상 연결된 두 컴퓨터가 서로 감염이 되게 할 수 있다는 점에서 두 개의 `node1`과 `node2`에 대해 양방향 간선을 아래와 같이 추가해준다.

```java
graph.get(node1).add(node2); // node1 -> node2의 간선
graph.get(node2).add(node1); // node2 -> node1의 간선
```

방문 순서는 오름차순이므로 `list.sort(Collections.reverseOrder())`를 통해 각 정점에 대해 정렬해주고, 시작 정점으로부터 DFS를 돌려준 뒤, 1번 노드부터 방문 순서를 `visitNumArr[]` 배열의 값을 받아와 출력하면 된다. `StringBuiler`를 사용하였다.


## 정리
DFS를 사용하는 가장 기본적인 문제 중 하나이다. 정렬 순서만 바꾸면, 24479 (알고리즘 수업 - 깊이 우선 탐색 1) 문제와 동일하다.
