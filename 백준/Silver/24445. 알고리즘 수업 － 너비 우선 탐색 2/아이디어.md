# 아이디어
BFS(너비 우선 탐색) 알고리즘을 직접 구현해서 풀면 된다.

## 문제 파악하기
$N$개 정점과 $M$개 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터 $N$번이고 모든 간선의 가중치는 1이다. 정점 $R$에서 시작하여 너비 우선 탐색으로 노드를 방문할 경우 노드의 방문 순서를 출력하자. 너비 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 **내림차순**&ZeroWidthSpace;으로 방문한다.

```
bfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점
    for each v ∈ V - {R}
        visited[v] <- NO;
    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.
    enqueue(Q, R);  # 큐 맨 뒤에 시작 정점 R을 추가한다.
    while (Q ≠ ∅) {
        u <- dequeue(Q);  # 큐 맨 앞쪽의 요소를 삭제한다.
        for each v ∈ E(u)  # E(u) : 정점 u의 인접 정점 집합.(정점 번호를 내림차순으로 방문한다)
            if (visited[v] = NO) then {
                visited[v] <- YES;  # 정점 v를 방문 했다고 표시한다.
                enqueue(Q, v);  # 큐 맨 뒤에 정점 v를 추가한다.
            }
    }
}
```

---

입력은 다음과 같이 주어진다:
- 첫째 줄에 정점 수 $N$, 간선 수 $M$, 시작 정점 $R$이 주어진다.
- $N$은 5 이상 10만 이하의 자연수, $M$은 20만 이하의 자연수, $R$은 $N$ 이하의 자연수로 주어진다.
- 다음 $M$개 줄에 간선 정보 $u$ $v$가 주어지고, 이는 정점 $u$와 $v$의 가중치 1인 양방향 간선을 의미하며 $u$와 $v$는 서로 같지 않고, 항상 $u < v$이면서 모든 간선의 쌍 값이 다름이 자명하다.

출력은 첫째 줄부터 $N$개 줄에 대해 정수를 한 개씩 출력하는데, $i$번째 줄에는 정점 $i$를 방문하는 순서를 출력한다. 시작 정점의 방문 순서는 1이며, 방문 불가한 경우 0을 출력한다.

## 방법 고안
BFS 코드를 직접 구현해보는 데 의미를 가지는 문제이다. 의사 코드도 주어져 있고 BFS 알고리즘을 정말 구현해보는 것 자체가 문제이기 때문에 특별히 설명할 건 없다.

## 코드화
### BFS 로직
```java
public class Main {
    public static List<List<Integer>> graph = new ArrayList<>();
    public static boolean[] visited;
    public static int[] visitNumArr;
    public static int depth = 0;

    public static void bfs(int startNode) {
        visited[startNode] = true;
        visitNumArr[startNode] = ++depth;

        Queue<Integer> Q = new ArrayDeque<>();
        Q.offer(startNode);
        while (!Q.isEmpty()) {
            int cur = Q.poll();
            for (int node : graph.get(cur)) {
                if (!visited[node]) {
                    visited[node] = true;
                    visitNumArr[node] = ++depth;
                    Q.offer(node);
                }
            }
        }
    }
```

각각의 노드에 대해 갈 수 있는 모든 노드를 `List<Integer>`로 저장하여 그래프는 `List<List<Integer>>` 형태로 저장된다. 방문한 곳을 다시 방문하지 않기 위하여 `boolean[] visited` 배열을 만들어주었고, `int[] visitNumArr`을 만들어 몇 번째 방문했는지 저장한다. `depth`는 방문하는 순서를 저장하는 변수이다.

`bfs` 로직은 다음과 같이 진행한다.
- `visited[]` 배열에서 해당 `startNode`를 방문했다고 `true`로 기록하고, `depth`를 1 증가시켜 `visitNumArr[]` 배열에서 해당 노드를 방문한 순서를 기록한다.
- `Q`라는 큐 자료구조(물론 `ArrayDeque`를 사용했지만)를 활용하여, `startNode` 를 맨 뒤에 추가한다.
- 자료구조 내에서 맨 앞의 요소를 삭제한다. 맨 앞의 요소를 `cur`로 받아온 뒤, 그 요소에 대해 인접한 정점 집합을 받아온다.
- enhanced-for loop를 활용하여 그 노드를 돌면서 각 `node`가 방문한 곳인지 아닌지 확인하고, 방문하지 않은 곳이라면 해당 `node`를 방문했다고 표시하면서 `depth`를 1 증가하여 `visitNumArr[]` 배열에 몇 번째로 방문했는지 저장하고 큐 맨 뒤에 해당 정점을 추가한다.

### main 메소드
```java
	...
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringBuilder sb = new StringBuilder();

        StringTokenizer st = new StringTokenizer(br.readLine());
        int node = Integer.parseInt(st.nextToken());
        int line = Integer.parseInt(st.nextToken());
        int startNode = Integer.parseInt(st.nextToken());

        visited = new boolean[node + 1];
        visitNumArr = new int[node + 1];

        for (int i = 0; i <= node; i++)
            graph.add(new ArrayList<Integer>());

        for (int i = 0; i < line; i++) {
            st = new StringTokenizer(br.readLine());
            int node1 = Integer.parseInt(st.nextToken()), node2 = Integer.parseInt(st.nextToken());
            graph.get(node1).add(node2);
            graph.get(node2).add(node1);
        }

        for (int i = 0; i <= node; i++)
            graph.get(i).sort(Collections.reverseOrder());

        bfs(startNode);
        for (int i = 1; i <= node; i++)
            sb.append(visitNumArr[i]).append("\n");
        bw.write(sb.toString());
        bw.flush();
    }
}
```

이제 할 일은 각각의 값을 받아 BFS를 돌리기만 하면 된다.
- `node`와 `line`은 각각 정점과 간선의 개수이며, `startNode`를 통해 시작 정점 번호를 저장한다.
- `visited`와 `visitNumArr` 두 배열에 대해서는 0번의 인덱스를 사용하지 않기 때문에 `node+1`의 크기를 가져야 1번부터 번호를 매길 수 있다.

0번 인덱스는 사용하지 않는다고 하였기 때문에 `node` 번호까지 for 문을 돌려서 그래프 기반을 마련하고, `line`의 개수만큼 for 문을 돌려서 각각의 간선을 모두 추가해준다. 이때, 연결된 두 개의 `node1`과 `node2`에 대해 양방향 간선을 아래와 같이 추가해준다.

```java
graph.get(node1).add(node2); // node1 -> node2의 간선
graph.get(node2).add(node1); // node2 -> node1의 간선
```

방문 순서는 내림차순이므로 `list.sort(Collections.reverseOrder())`를 통해 각 정점에 대해 정렬해주고, 시작 정점으로부터 BFS를 돌려준 뒤, 1번 노드부터 방문 순서를 `visitNumArr[]` 배열의 값을 받아와 출력하면 된다. `StringBuiler`를 사용하였다.


## 정리
오름차순으로 바꾸기만 하면 24444 (알고리즘 수업 - 너비 우선 탐색 1) 문제와 같다.

**BFS(Breadth-First Search)**&ZeroWidthSpace;는 이름 그대로 넓이 우선 탐색이다.즉, 한 노드에서 가까운 노드부터 차례대로 방문하는 방식이다.

이를 구현하려면:
- 방문할 순서를 기억해야 하고
- 먼저 넣은 노드를 먼저 처리해야 한다.

이 두 가지 조건을 만족하는 자료구조가 **큐(Queue)**&ZeroWidthSpace;이고, 큐는 "선입선출(First In, First Out, FIFO)" 구조라서 **먼저 발견된 노드 → 먼저 처리**&ZeroWidthSpace;가 자연스럽게 진행된다.

이는 놀이공원 줄 서기와 비슷한 느낌이다.
1. 줄에 서는 순간 방문 표시
2. 앞사람부터 입장, 큐의 앞에서 꺼내기
3. 친구들을 데리고 왔다면 친구들은 줄 맨 뒤에 서게 함
4. 줄이 빌 때까지 반복하여 모든 노드를 처리함

이 과정을 거치면 먼저 발견된 노드일수록 먼저 처리되고, 각 노드는 한 번만 방문하며 거리 순서로 탐색 가능하다. 만약 큐 대신 다른 스택이나 재귀를 쓰면 방문 순서가 **깊이 우선**&ZeroWidthSpace;으로 변경된다.

