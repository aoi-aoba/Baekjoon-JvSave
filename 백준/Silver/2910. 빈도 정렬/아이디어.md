# 아이디어
정렬을 잘 사용해서 풀 수 있는 문제. 다만, 이 수들을 어떻게 저장해야 할 지는 생각해보아야 한다. 수의 범위가 매우 넓다는 것에 주의!

## 문제 파악하기
메시지에 숫자 $N$개가 있다. 숫자는 모두  $C$보다 작거나 같다. 이 숫자들을 자주 등장하는 빈도순대로 정렬하려 한다.

- 수열의 두 수 $X$, $Y$가 있을 때, $X$가 $Y$보다 수열에서 많이 등장하는 경우 $X$가 $Y$보다 앞에 있어야 한다.
- 만약, 등장 횟수가 같다면, 먼저 나온 것이 앞에 있어야 한다.

다음과 같은 정렬 방법을 빈도 정렬이라고 한다. 수열이 주어지면, 빈도 정렬을 하는 프로그램을 작성하자.

---

입력은 다음과 같이 주어진다:
- 첫 줄에는 메시지 길이 $N$이 1,000 이하의 자연수로, 그리고 $C$가 $10^9$ 이하의 자연수로 주어진다.
- 둘째 줄에 메시지 수열이 주어진다.

출력으로 첫째 줄에 입력 수열을 빈도 정렬한 다음 출력한다.

## 방법 고안
문제에서 중요한 단서는 '등장 횟수'와 '먼저 나온 것' 두 가지에 집중해야 한다.

### 등장 횟수와 먼저 나온 순서를 어떻게 저장할 것인가?
어떤 수에 대하여 그 수의 등장 횟수와 나온 순서를 저장해야 하기 때문에, `int[]`를 생각할 수도 있겠지만 그렇다면 관리가 어렵다. 그러므로, 아예 하나의 객체를 만들 수도 있고, 리스트나 배열과 같은 것으로 지정할 수도 있다. 여기에서는 어차피 숫자가 막 섞여 나오는 수열에 대하여, 어떤 수가 나올 때 그 수의 등장 횟수나 나온 순서를 조정하면 되기 때문에 어떤 숫자를 `key`로서 받아들이고 `value`를 변경하는 방식의 `HashMap`을 사용하는 것이 가장 효과적이라고 판단하였다.

$C$의 범위가 $10^9$인데, `int` 범위 내에 있다고 굳이 `int[][]`같은 2차원 배열로 하여 `new int[1000000000][2]`로서 각 인덱스를 두는 것은 굉장히 비효율적이다. 그 배열을 돌면서 나온 숫자를 찾는 것도 일이고, 메모리 낭비도 심하다.

### 정렬은 어떻게 할 수 있을까?
객체를 사용했다면, `implements Comparable`을 활용하여 비교 규칙을 설정할 수 있을 것이지만, `HashMap`을 운용하고 있기 때문에 `Collections.sort()` 내지는 `HashMap`의 `keySet()` 메소드로 키 값을 리스트로 받아와 `list.sort()`의 새 `Comparator` 규칙을 만드는 것이 가장 바람직한 방법일 것이다.

그래서, 아예 등장 횟수와 먼저 나온 순서를 `HashMap`으로 각각 만들어서 그 값을 `HashMap.get()` 메소드를 활용하여 비교하는 방식으로 새 규칙을 만들어 정렬하였다.

---

## 코드화
### 기본 입력 처리 및 Map 구조화
```java
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();

        StringTokenizer st = new StringTokenizer(br.readLine());
        int N = Integer.parseInt(st.nextToken()), C = Integer.parseInt(st.nextToken());

        Map<Integer, Integer> freqMap = new HashMap<>();
        Map<Integer, Integer> startIdxMap = new HashMap<>();

        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < N; i++) {
            int temp = Integer.parseInt(st.nextToken());
            if (freqMap.containsKey(temp))
                freqMap.put(temp, freqMap.get(temp) + 1);
            else {
                freqMap.put(temp, 1);
                startIdxMap.put(temp, i);
            }
        }
```
입력을 받아오고, `Map<Integer, Integer>`의 형태로  `freqMap`과 `startIdxMap`을 두 개 각각 운용한다. `freqMap`은 그 숫자가 나타난 빈도 수를, `startIdxMap`은 더 먼저 나타난 숫자를 파악하기 위한, 그 숫자가 처음 나타난 인덱스 값을 저장하는 맵이다.

- 만약, `freqMap`에 해당 숫자가 있다면 이미 등장했다는 것이므로, `value` 값을 받아와서 1만 더해서 빈도수를 변경해준다.
- 그렇지 않다면 처음 나타난 것이므로, `freqMap`에 빈도수 1로 새로 값을 넣어주고, `startIdxMap`에 처음 나타난 인덱스 번호인 `i`를 직접 넣어준다.

그러면 `key`인 하나의 숫자로서 빈도수와 처음 나타나는 인덱스 번호를 받아올 수 있게 된다.

### 정렬과 출력
```java
		...
        List<Integer> keyList = new ArrayList<>(freqMap.keySet());
        keyList.sort(new Comparator<Integer>() {
            @Override
            public int compare(Integer key1, Integer key2) {
                if (freqMap.get(key1).equals(freqMap.get(key2)))
                    return startIdxMap.get(key1) - startIdxMap.get(key2);
                    // 나타난 순서는 첫 인덱스 기준 오름차순 정렬
                else return freqMap.get(key2) - freqMap.get(key1);
                // 빈도는 내림차순 정렬
            }
        });

        for (int num : keyList) {
            for (int i = 0; i < freqMap.get(num); i++)
                sb.append(num).append(" ");
        }

        System.out.println(sb);
    }
}
```

`key` 값 하나로 모든 `HashMap`을 운용하는 것이 가능하므로 `keySet()` 메소드로 두 맵 중 하나의 키 값을 모두 가져와 `keyList`에 저장한다. 이것을 이제 적절히 정렬하기 위해 `keyList.sort()`의 새로운 정렬 규칙을 지정한다.

- 두 수에 대하여, 빈도수가 같다면 가장 먼저 나타난 숫자가 먼저이므로 인덱스 기준 오름차순 정렬해야 한다. 즉, `startIdxMap.get()`을 활용하여 받아온 값을 오름차순 정렬해야 하므로 `key1`의 값에서 `key2`의 값을 빼 준다.
- 빈도수가 같지 않다면 가장 상위의 규칙으로서 더 많이 나타난 숫자가 먼저이므로, `freqMap.get()` 값을 활용하여 내림차순 정렬해야 한다. `key2`의 값에서 `key1`의 값을 빼 준다.

> 여기에서, `-`를 사용하는 것이 아니라, `Integer.compare(int x, int y)` 메소드를 활용하여 비교해도 된다.

그 결과에 따라 정렬된 `keyList`에서 enhanced-for loop를 활용하여 값들을 받아와 `freqMap`에서 빈도수를 체크, 그 값을 `StringBuilder`에 일괄적으로 `append`하여 마지막에 한 번에 출력한다.

## 정리
정렬 규칙과 해시를 활용한 맵 구조를 활용하면 큰 어려움 없이 풀 수 있는 문제였다.
