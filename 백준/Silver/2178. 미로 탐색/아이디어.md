# 아이디어
전체 미로를 움직이면서 최단 거리를 파악해야 한다. 여기에서, DFS(깊이 우선 탐색)의 경우에는 최단 거리를 보장할 수 없다는 점에 유의해야 한다. 그렇다면, 우리는 BFS(너비 우선 탐색) 형태로 접근해야 한다는 것을 알 수 있다.

## 문제 파악하기
$N \times M$ 크기의 배열로 표현되는 미로가 있다. 이 미로에서 **1은 이동할 수 있는 칸**&ZeroWidthSpace;을 나타내고, **0은 이동할 수 없는 칸**&ZeroWidthSpace;을 나타낸다. 이러한 미로가 주어졌을 때, $(1, 1)$에서 출발하여 $(N, M)$의 위치로 이동할 때 지나야 하는 최소 칸 수를 구하는 프로그램을 작성하자. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다. 칸을 셀 때는 **시작 위치와 도착 위치도 포함**&ZeroWidthSpace;한다.

---

입력은 다음과 같이 주어진다:
- 첫 번째 줄에는 정수 $N$과 $M$이 주어진다. 두 정수 모두 2 이상 100 이하의 범위로 주어진다.
- 각각의 수들은 **붙어서** 입력으로 주어진다.

출력은 첫째 줄에 지나야 하는 최소 칸 수를 출력해야 하며, 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.

## 방법 고안
이차원 배열을 순회하면서 '최단거리'를 찾아야 하기 때문에 BFS가 적절하다.

### 너비 우선 탐색과 깊이 우선 탐색을 통해 이차원 배열을 순회하는 방법
우선, BFS에 대하여 생각해보자. 너비 우선 탐색은 그래프 상에서도 한 정점으로부터 나아갈 수 있는 다른 정점을 모두 생각해보고, 그것을 차례차례 순회하는 방식이었다. 그렇다면, 네 개 방향(상하좌우)에 위치한 곳을 각각의 정점으로 간주한다면 비슷한 방식으로 순회가 가능할 것이다. **즉 Queue 구조를 활용하여 순회하는 것을 사용**&ZeroWidthSpace;한다면 일반적인 BFS를 사용하는 것과 동일하게 풀 수 있을 것이다.

DFS는 어떨까? 깊이 우선 탐색은 그래프 상에서, 한 정점으로부터 나아갈 수 있는 대로 쭉쭉 뻗어나가서 더 이상 나아갈 수 없으면 다시 돌아오는 방식을 택한다. 그러면, 어떤 한 지점에 대하여 계속 dx-dy technique를 사용하여 **나아갈 수 있는 인접한 단지로 계속 뻗어나가 더 이상 그것이 네 개 방향 어디로도 불가능한 상황**&ZeroWidthSpace;까지 나아가면 한 개의 단지를 찾을 수 있을 것이다. **방문한 곳을 다시 가지 않아도 된다는 점**&ZeroWidthSpace;에서 이 반복이 끝나는 지점은 명료하다.

![](https://velog.velcdn.com/images/aoi-aoba/post/e4960e94-8842-4544-86de-de0c742828ee/image.png)

즉, 너비 우선 탐색은 위의 그림처럼 각 위치에 대하여 갈 수 있는 모든 경로를 Queue 구조를 활용하여 그래프에서의 알고리즘 분석처럼 뻗어나가는 모양이 그려지고, 깊이 우선 탐색의 경우는 한 위치에서 갈 수 있는 곳을 계속 쭉 넘어가다가 더 이상 갈 수 없으면 재귀 함수처럼 뒤로 다시 돌아가 쭉쭉 뻗어나가는 방식으로 넘어가면 된다.

### 미로 최단거리 찾기에 왜 DFS를 사용하는 것이 비합리적인가
BFS는 한 깊이의 모든 노드를 방문한 뒤 다음 깊이로 넘어가기 때문에 처음 도착한 시점이 곧 최단 거리이다. 그래서 큐에 해당 지점의 좌표와 거리를 넣어서 순차적으로 꺼내면, 가장 먼저 도착한 값이 바로 최단 거리라고 알 수 있다.

하지만 DFS는 탐색 순서가 **깊이 우선이기 때문에** 첫 번째 도착 경로가 최단이 아닐 수 있다. 모든 가능한 경로를 끝까지 확인하고, 그 중 최단거리를 따로 비교해야 한다. 그러면, 가능한 경로가 많아질수록 시간 복잡도가 급격하게 증가하게 된다. 그래서 DFS로 접근한다면 모든 경로 탐색, 즉 최악의 경우 $O(2^{NM})$ 수준까지 갈 수 있다.

백트래킹을 활용하여 탐색을 하면 DFS로도 탐색은 가능하지만, 굳이 이 방법을 사용할 이유가 없다.

### BFS를 사용하여 최단거리를 찾으려면?
방문 배열(`visited[][]`)을 활용할 때, 방문 여부만 체크하는 것이 아니라 방문했을 때의 거리를 체크해보자. 그러면, 큐에 좌표만 넣지 말고 그 좌표에 가는 '거리'까지 넣어서 순차적으로 꺼내면 최단거리를 파악할 수 있다.

---

## 코드화
### BFS를 활용하기 위한 메소드 구조
```java
public class Main {
    public static boolean[][] map;
    public static int[][] visited;
    public static int[] dx = {-1, 1, 0, 0};
    public static int[] dy = {0, 0, -1, 1};
    public static int n, m;

    public static void bfs(int posX, int posY, int dist) {
        Queue<int[]> Q = new ArrayDeque<>();
        Q.offer(new int[]{posX, posY, dist});
        visited[posY][posX] = 1;

        while (!Q.isEmpty()) {
            int[] pos = Q.poll();
            int x = pos[0], y = pos[1], d = pos[2];

            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i], ny = y + dy[i];
                if (nx >= 0 && nx < m && ny >= 0 && ny < n && map[ny][nx] && visited[ny][nx] == 0) {
                    visited[ny][nx] = d + 1;
                    Q.offer(new int[]{nx, ny, d + 1});
                }
            }
        }
    }
```

`boolean[][]` 이차원 배열 `map`은 0과 1을 각각 `false`와 `true`로 하여 저장하고, `int[][]` 이차원 배열 `visited`는 거리를 저장함과 함께 방문 여부를 확인한다. dx-dy를 돌아볼 수 있게 배열을 지정하고, 크기 $m$과 $n$ 역시 모두 전역으로 설정했다.

일반적인 `bfs` 알고리즘과 비슷한 방식으로 돌 수 있다.
- `bfs(int startX, int startY)`의 형태로 parameter로 주어지는 최초 시작 지점을 기준으로 Queue를 만들어서 이 안에 최초 지점을 삽입한다. 이때, 최초 지점도 거리로 포함하기 때문에, `dist`까지 포함하여 저장하는 방식으로 거리를 계산한다.
- Queue가 `isEmpty()`를 통해 비어있지 않은 동안, 좌표를 하나씩 꺼내어 순회한다. 이 지점을 각각 `x`, `y`라는 변수에 좌표를 지정한다. 거리 역시 `d`라는 변수에 지정한다. 그리고 for 문을 이용해 이동한 `nx`, `ny`의 값을 구한다.
- 해당 값이 '범위 내에 존재'하는지, 이미 본 곳은 아닌지 체크한 다음, 만약 그게 모두 맞다면 `true`로 바꾸고 Queue에서 살펴볼 곳으로 값을 뒤에 추가한다. 그리고 해당 지점을 이전 지점의 거리에 1을 더해서 체크하면 된다.
- 앞에서부터 값을 계속 돌면서 체크하고, `visited` 배열에 계속 작성하면 된다.

### main 메소드
```java
	...
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());

        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());
        map = new boolean[n][m];
        visited = new int[n][m];

        for (int i = 0; i < n; i++) {
            String str = br.readLine();
            for (int j = 0; j < m; j++) {
                map[i][j] = str.charAt(j) == '1';
            }
        }

        bfs(0, 0, 1);
        System.out.println(visited[n-1][m-1]);
    }
}
```
메인 메소드 부분은 모두 같다. 각각의 테스트케이스에 대하여 값을 받아오고, `map[][]`, `visited[][]`의 이차원 배열을 초기화한다. 입력으로 주어지는 맵을 입력하고, 이때 1을 `true`로 하여 `boolean[][]` 배열에 지정한다. 시작지점은 배열 기준으로는 `[0][0]` 지점이고 시작지점도 거리에 포함하기 때문에, `bfs(0, 0, 1)`로 시작하여 `visited`에 저장된 마지막 지점의 값을 출력하면 된다.
