# 아이디어
그래프가 어떻게 구성되어있는지 순회하면서 체크하는 것이 포인트. 그래프 이론 문제 중에서 가장 간편하게 풀어볼 수 있는 문제이다.

## 문제 파악하기
어떤 방향 없는 그래프가 주어졌을 때, 연결 요소(Connected Component)의 개수를 구하는 프로그램을 작성하여라.

---

입력은 다음과 같이 주어진다:
- 첫째 줄에 정점 개수 $N$과 간선 개수 $M$이 주어진다.
- 두 수의 범위는 $1 ≤ N ≤ 1,000$, $0 ≤ M ≤ N×(N-1)/2$이다.
- 둘째 줄부터 $M$개 줄에 간선의 양 끝점 $u$와 $v$가 주어진다. ($1 ≤ u, v ≤ N$, $u ≠ v$)
- 같은 간선은 한 번만 주어진다.

출력으로 첫째 줄에 연결 요소의 개수를 출력하자.

## 방법 고안
'연결 요소'라는 것이 무엇인지 생각해본다면 쉽게 풀이할 수 있다.

### 연결 요소(Connected Component)란?
그래프는 항상 모든 간선이 유기적으로 연결되어있다는 보장은 없다. 정점 사이에 겹치는 것이 없이 분리되어 있어도 하나의 그래프로 볼 수 있는데, 연결 요소라는 것은 이처럼 정점 사이에 겹치는 것 없이 나누어진 각각의 그래프를 하나의 연결 요소로 볼 수 있다. 다만, 조건은 필요하다.
- 연결 요소에 속한 모든 정점을 연결하는 경로가 있어야 한다.
- 또 다른 연결 요소에 속한 정점과 연결하는 경로가 있으면 안 된다.

![](https://velog.velcdn.com/images/aoi-aoba/post/209d04d9-15d3-4b98-ae48-fd42a016bf13/image.png)

위와 같은 그래프가 있다고 가정해보자. 2, 3, 4, 7번 노드는 한 번에 연결되어 있어 각각이 유기적으로 이동할 수 있다. 아래의 0, 1, 5, 6번 노드도 그러하다. 하지만 각각의 분리된 상태에서 5번과 2번은 절대 연결될 수 없다. 7번과 0번도 그러하다. 이런 경우에 우리는 각각을 하나의 '연결 요소'로 보고, 총 2개의 연결 요소가 있다고 할 수 있는 것이다.

![](https://velog.velcdn.com/images/aoi-aoba/post/3a9eb829-7918-4de8-b60b-801676a49b2f/image.png)

연결 요소가 하나인 경우는 위와 같다. 모든 정점 간에 연결된 간선이 존재하기 때문이다.

### 연결 요소의 판단
간단히 생각해보면, 모든 노드에 대해서 순차적으로 돌아보면서 색을 칠한다는 개념으로 접근하는 것이 좋다. 
![](https://velog.velcdn.com/images/aoi-aoba/post/d97c77da-f7ed-4e00-ac5f-5b46a5cfb05e/image.png)

위와 같은 그래프가 있다면, 0번부터 시작해서 해당 노드가 가지고 있는 간선을 타고 계속 이동하며 색을 칠해보는 것이다.
![](https://velog.velcdn.com/images/aoi-aoba/post/ca563a1f-26ef-468d-808d-2d81fa975458/image.png)

그러면, 0번을 통해 5번과 7번 노드를 갈 수 있다. 그 다음 1번 노드를 보면 색이 칠해져 있지 않으므로 2번과 6번 노드를 칠할 수 있다. 그런 다음, 2번 노드를 보면 색이 칠해져 있다. 스킵한다. 그 다음, 3번 노드는 칠해져 있지 않으므로 간선을 타고 4번과 8번 노드에 색을 칠할 수 있다. 그 이후는 모두 색이 칠해져 있으므로 더 이상 체크할 필요가 없다. 그러면 연결 요소는 '사용된 색의 개수' 인 셈이므로, 총 3개임을 알 수 있다.

이 과정에서 BFS 알고리즘 혹은 DFS 알고리즘을 사용한다면 쉽게 풀이가 가능함을 알 수 있다.

---

## 코드화
### DFS 알고리즘
```java
public class Main {
    public static int N, M;
    public static boolean[] visited;
    public static List<boolean[]> graph = new ArrayList<>();
    public static void dfs(int startNode) {
        for (int i = 1; i <= N; i++) {
            if (!graph.get(startNode)[i] || i == startNode) continue;
            if (!visited[i]) {
                visited[i] = true;
                dfs(i);
            }
        }
    }
```
DFS 알고리즘을 활용하여 그래프를 순회하는 방식을 채택하였다. 어떤 노드를 입력으로 받는다면, 해당 노드가 자기 자신이거나 그 노드와 연결되지 않은 경우를 1~N번 노드까지 확인하다가 만약 방문한 적 없는 노드인데 연결된 노드라면 `true`로 바꾸고 해당 노드로 이동하여 `dfs`를 다시 도는 방식이다. 순환적으로 계속 노드를 타고 넘어가 연결 요소를 빙빙 도는 것이다.

### Main 메소드
```java
public static void main(String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer st = new StringTokenizer(br.readLine());
    N = Integer.parseInt(st.nextToken());
    M = Integer.parseInt(st.nextToken());

    for (int i = 0; i < N + 1; i++) graph.add(new boolean[N + 1]);
    visited = new boolean[N + 1];

    for (int i = 0; i < M; i++) {
        st = new StringTokenizer(br.readLine());
        int u = Integer.parseInt(st.nextToken()), v = Integer.parseInt(st.nextToken());
        graph.get(u)[v] = true;
        graph.get(v)[u] = true;
    }

    int cnt = 0;
    for (int i = 1; i <= N; i++) {
        if (visited[i]) continue;
        else {
            visited[i] = true;
            cnt++;
            dfs(i);
        }
    }

    System.out.println(cnt);
}
```

main 부분에서는 입력을 받아서, 전역 선언되어 있는 `N`과 `M`의 값을 대입해둔다. 그 값에 따라 전역의 `graph`를 생성하는데, 해당 그래프는 모든 경우의 수에 대하여 유향 그래프처럼 간선을 저장한다. `graph`의 `i`번 인덱스에 `1~N`번의 인덱스 정점과의 관계를 체크하기 위한 `boolean` 배열을 생성하고, 무향 그래프이기 때문에 간선을 양 방향으로 체크해두는 것이다.

아래쪽의 `for` 문에서는 1번부터 차례대로 돌면서, 만약 방문한 적 있다면 넘어가고 방문한 적 없다면 새로운 색을 하나 골라서 색칠하듯 `cnt`를 1 증가시키고 해당 노드의 방문 여부를 `true`로 바꾼 다음, `dfs()`를 해당 노드부터 돌리면 된다.

## 정리
복잡하게 생각할 것 없이 그래프의 연결 요소 개념만을 이해하고 있다면 쉽게 풀이할 수 있었다. bfs로도 풀 수 있는 문제.
