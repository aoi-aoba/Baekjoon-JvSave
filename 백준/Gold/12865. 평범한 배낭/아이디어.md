# 아이디어
냅색 알고리즘(knapsack algorithm)의 가장 대표적인 문제이다. 그 중에서도 분할이 불가능한 0-1 냅색 문제인데, 이 문제는 일반적으로 DP(다이나믹 프로그래밍)으로 풀 수 있다고 알려져 있다.

## 문제 파악하기
준서가 여행에 필요하다고 생각하는 $N$개 물건은 각각 무게 $W$와 가치 $V$의 값을 가진다. 해당 물건을 배낭에 넣어서 가면 준서가 $V$만큼 즐길 수 있다고 한다. 준서가 최대 $K$만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다고 할 때, 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 구해보자.

---

입력은 다음과 같이 주어진다:
- 첫 줄에는 물품 개수와 준서가 버틸 수 있는 무게 $N$ 과 $K$가 주어진다.
- $N$은 100 이하의 자연수, $K$는 10만 이하의 자연수이다.
- 두 번째 줄부터 $N$개 줄에 걸쳐 각 물건 무게 $W$와 해당 물건 가치 $V$가 주어진다.
- $W$는 10만 이하의 자연수이며, $V$는 0 이상 1000 이하의 정수이다.

출력으로 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력하자.

## 방법 고안
냅색 알고리즘 문제를 어떻게 푸는 지에 대해 생각해보는 문제가 될 수 있겠다.

### 일반적으로 생각해보자
주어진 상황은 다음과 같다.
- 6kg, 가치 13의 물건
- 4kg, 가치 8의 물건
- 3kg, 가치 6의 물건
- 5kg, 가치 12의 물건

동적 계획법(다이나믹 프로그래밍)의 방식을 차용하여 문제를 풀어보기 이전에, 당장 그냥 이 물건들을 직접 생각해보자.

준서가 버틸 수 있는 무게 $K$에 대하여,
- $K$가 3보다 작다면 아무 물건도 담을 수 없다.
- $K$가 3이라면, 3kg의 물건을 담을 수 있고 가치는 6이다.
- $K$가 4라면, 4kg의 물건을 담을 수 있고, 가치는 8이다.
- $K$가 5라면, 5kg의 물건을 담을 수 있고, 가치는 12이다.
- $K$가 6이라면, 6kg의 물건을 담을 수 있고, 가치는 13이다.
- $K$가 7일 때 물건들에 대해 생각해보자.
  - 6kg 물건을 담는다면 1kg이 남고, 이때는 아무 물건도 담을 수 없기 때문에 가치는 13이다.
  - 5kg 물건을 담는다면 2kg이 남고, 역시 동일하게 아무 물건도 더 담을 수 없어 가치는 12이다.
  - 4kg 물건을 담는다면 3kg이 남고, $K$가 3일 때 담을 수 있는 3kg의 물건이 있었으며 가치가 6이었다. 그러므로 이때 우리는 가치가 8 + 6 = 14가 됨을 알 수 있다.
  - 3kg 물건을 담으면 4kg이 남고, 이건 아까와 같은 상황이다.

즉, 지금 상황을 통해 우리가 구하는 답이 14임을 알 수 있다.

이 상황을 다이나믹 프로그래밍으로 구현하는 것이다. 어떤 물건을 담을 수 있는지 $K$의 값을 늘려가면서 체크하고, 어떤 물건 $i$의 무게 $W_i$를 선택하려 했을 때, $K - W_i$일 때 담을 수 있는 물건이 있었는지, 그 가치는 어떤지 체크한 다음 그 값에 물건 가치 $V_i$를 더해주는 것이다.

### 2차원 DP Table로 구현해보자
위에서 생각한 상황을, 직접 표로 그리면 다음과 같이 나타난다.
![](https://velog.velcdn.com/images/aoi-aoba/post/ba6d2fd8-a667-4179-b5ed-3487b777465a/image.png)

0kg을 담을 수 있는 상황부터 물건 번호를 돌아보자. 물건번호 0은 index 시작을 1로 맞춰주기 위한 것이고, 0kg은 아무것도 담을 수 없으므로 이 열과 행은 모두 0이다. 1kg과 2kg 역시 돌면서 아무것도 담을 수 없다. 그러므로, 여기 역시 0으로 모두 채워진다.

3kg 부분부터 바라보면, 1번 물건과 2번 물건은 담을 수 없지만, 3번 물건을 담을 수는 있다. 그러므로 3번 물건을 담은 것으로 보고 6 가치를 쳐 준다. 4번 물건은 담을 수 없다. 그러므로 위의 값을 그대로 받아와서 적어준다. 그 말인즉,
> 1번부터 4번의 물건을 확인해본 결과, 3kg 가방에 담을 수 있는 최대 가치는 6이다.

라는 방식으로 기록하는 것이라 보면 된다.

4kg을 보자. 그러면, 2번 물건을 담을 수 있으면서 파란 부분이 8로 바뀐다. 3번과 4번을 돌아보면서 보면, 담을 수 있는 게 없다. 그러므로 8을 그대로 받아온다.

5kg 역시 그렇게 진행하는데, 여기에서 2번 물건을 예시로 보자.
- 5kg의 가방에 2번 물건을 담는다면 남는 무게는 1kg이다.
- 남는 무게인 1kg의 1번 물건에 대한 상황 칸을 보면, 해당 칸은 '0'의 가치가 있다.
- 그러므로 현재 가치는 8이 된다.

3번 물건에서도 그렇게 기록할 수 있겠고, 4번 물건은 그렇게 하면 12의 가치가 되는데, 여기에서 우리는 계속 전제로서 '위의 값을 그대로 받아와서 적어주어 $1$번에서 $N$번까지 본 결과의 최댓값을 체크'하고 있다고 했으므로 윗 칸의 8과 현재 계산 결과인 12 중 최댓값인 12를 적는 것이다.

계속 진행하면 6kg에서는 1번 물건을 담은 것이 가장 가치가 크므로 그 값을 계속 인계받고, 7kg 상황에서도 그런 방식으로 진행하다가, 다시 3번 물건을 보자.
![](https://velog.velcdn.com/images/aoi-aoba/post/671326d2-2066-49b4-b632-d97cdbee0dff/image.png)

- 7kg의 가방에 3번 물건을 담으면 남는 무게는 4kg이다.
- 이때, 우리가 **'3번 물건을 넣으려는' 것이므로, 2번 물건까지의 결과를 확인해보자.** 4kg의 **2번 물건까지의 확인 결과 최댓값은** (물건번호 2의 무게 4칸) 8이라는 값이 적혀있다.
- 3번 물건의 가치는 6이었으므로, 새로운 가치 값 $8+6=14$를 계산해내어 위 칸과 비교해 더 큰 값인 14를 저장한다.

그럴 때 마지막 칸까지 모두 조사하여 맨 마지막, $N$번 물건의 $K$ 무게의 상황의 최댓값을 출력해주면 되는 것이다.

> 물건 번호 $i$, 현재 최대 무게 $K_j (≤ K)$에 대하여   
> - 현재 최대 무게에서 현재 살펴보려는 물건 무게를 뺀, $K_j - W_i$의 값을, 물건 번호 $i-1$에서 살펴본다.
> - $i$번을 선택하려는 것이므로 이미 선택한 결과인 $i$ 열에서 살피면 $i$가 중복되어 선택됨에 주의한다.
> - 그 값에 현재 물건의 가치 $V_i$를 더한다.
> 
> 그 값과 $K_j$의 $i-1$ 칸의 가치 값을 비교하여 더 큰 것을 저장한다.

### 1차원 DP Table로도 가능하다
![](https://velog.velcdn.com/images/aoi-aoba/post/bd2f0256-2c34-4060-a00f-2fa7a920f92e/image.png)

기본 DP 테이블을 1차원으로 만들어도 충분히 구현 가능하다.

![](https://velog.velcdn.com/images/aoi-aoba/post/a90edf5f-ff07-4d33-8b74-ddec60ca796a/image.png)

물건 1번을 넣어보자. 이때, 확인하는 순서는 무게 7부터 0으로 역으로 확인한다. 그 이유는 이후에 다시 확인하고, 일단 7kg에는 물건이 들어갈 수 있으므로 13 가치, 6kg에도 동일하며 나머지는 들어갈 수 없으므로 0을 채운다.

![](https://velog.velcdn.com/images/aoi-aoba/post/2b535b88-2945-4c9e-b671-fee43a3e5e47/image.png)

위 DP 테이블을 다시 뒤에서부터 확인한다. 그러면 다음과 같이 진행된다. 물론, 이 때도 값을 채우는 방식은 동일하다. 테이블 내에서 무게 $K_j - W_i$를 계산한 칸을 찾아서 그 값에 $V_i$를 더하면 된다. 

![](https://velog.velcdn.com/images/aoi-aoba/post/c4dac6fd-5864-4b28-860e-a79cf0bc6f19/image.png)

다시 뒤에서 확인하며 쭉 진행해나가면 된다. 

![](https://velog.velcdn.com/images/aoi-aoba/post/671a4f56-2986-4967-a05e-28bc5a678185/image.png)

다음과 같이 진행됨에 따라 마지막 상황에 대해서 7kg에 저장된 가치를 출력하면 된다.

그러면, 왜 끝에서부터 확인해야 할까? 그건, 다음과 같은 문제가 발생할 수 있기 때문이다. 앞에서부터 확인하는 것으로 하고, 물건을 다음과 같이 새로 지정해보겠다. 한 개의 물건을 2kg, 13의 가치를 가지고 있다고 가정해보자. 그러면, 다음과 같이 문제가 발생함을 알 수 있다.

![](https://velog.velcdn.com/images/aoi-aoba/post/eeb6d995-d487-46b9-8633-ae1c87942c5f/image.png)

앞에서 이미 1번 물건을 선택했는데, 그걸 다시 중복 선택하여 값이 기하급수적으로 늘어나는 것을 볼 수 있다. 값을 뒤에서부터 참조하게 하면 이것을 막을 수 있는데, 왜냐하면 $K_j - W_i$의 값은 $K_j$ 보다 항상 작기 때문에, 참조하게 되는 칸의 값은 항상 $i-1$번째의 물건까지만 선택한 결과이기 때문이다.

> 물건 번호 $i$, 현재 최대 무게 $K_j (≤ K)$에 대하여   
> - 현재 최대 무게에서 현재 살펴보려는 물건 무게를 뺀, $K_j - W_i$의 값을 확인한다.
> - 이때, $K_j$는 $K$부터 $0$으로 역으로 순회함에 주의한다.
> - 그 값에 현재 물건의 가치 $V_i$를 더한다.
> 
> 그 값과 현재 $K_j$ 칸의 값을 비교하여 더 큰 것을 남긴다.

---

## 코드화
### 1차원 냅색 알고리즘의 구현 - 메소드와 전역 변수
```java
public class Main {
    static int N, K;
    static int[] weight, value, dpTable;

    public static int knapsack() {
        for (int i = 1; i <= N; i++) {
            for (int w = K; w >= 1; w--) {
                if (w >= weight[i])
                    dpTable[w] = Math.max(dpTable[w], dpTable[w - weight[i]] + value[i]);
            }
        }

        return dpTable[K];
    }
```
`N`과 `K`의 값은 전역으로 설정하여 받아두고, 물건의 무게와 가치를 담은 1차원 배열 `weight`과 `value`, 그리고 계산이 이루어지는 `dpTable`을 만든다.

- 1번부터 $N$번까지의 물건에 대해서 확인하되, 한 줄로 된 1차원 배열이기 때문에 각 물건에 대해 각각의 무게 `w`를 체크하면서 진행한다.
- 만약, `w`가 `weight[i]`, 즉 `i`번째 물건의 무게보다 크거나 같으면 그 물건을 가방에 담을 수 있으므로 계산을 진행한다.

> `dpTable[w-weight[i]] + value[i]`   
> - 현재 최대 무게에서 담을 물건의 무게 `weight[i]`를 뺀 값을 `dpTable`에서 가져온다.
> - 그 가치 값에서 `i`번째 물건 가치 값 `value[i]`를 더한 것.
> - 이것이 기존에 있던 `dpTable[w]`보다 커야 이 값을 저장한다. 아니면 기존 결과값 `dpTable[w]`를 그대로 사용한다.

마무리는 `dpTable[w]`를 `return` 해주면 된다.

### 1차원 냅색 알고리즘의 구현 - main 메소드
```java
	...
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        K = Integer.parseInt(st.nextToken());

        dpTable = new int[K + 1];
        weight = new int[N + 1];
        value = new int[N + 1];

        for (int i = 1; i <= N; i++) {
            st = new StringTokenizer(br.readLine());
            weight[i] = Integer.parseInt(st.nextToken());
            value[i] = Integer.parseInt(st.nextToken());
        }

        System.out.println(knapsack());
    }
}
```
이미 거의 만들어질 건 다 만들어졌기 때문에 각각의 정보를 배열에 집어넣고 `knapsack()` 메소드를 호출하기만 하면 끝이다.


### 2차원 냅색 알고리즘의 구현 - 메소드와 전역 변수
```java
public class Main {
    static int N, K;
    static int[] weight, value;
    static int[][] dpTable;

    public static int knapsack() {
        Arrays.fill(dpTable[0], 0);
        for (int i = 1; i <= N; i++) {
            for (int w = 0; w <= K; w++) {
                if (w < weight[i])
                    dpTable[i][w] = dpTable[i - 1][w];
                else
                    dpTable[i][w] = Math.max(dpTable[i - 1][w - weight[i]] + value[i], dpTable[i - 1][w]);
            }
        }

        return dpTable[N][K];
    }
```
`N`과 `K`의 값은 전역으로 설정하여 받아두고, 물건의 무게와 가치를 담은 1차원 배열 `weight`과 `value`, 그리고 계산이 이루어지는 2차원 배열 `dpTable`을 만든다.

- 무게 0, 그리고 0번 물건은 존재하지 않기 때문에 이 부분은 index 값을 맞춰주기 위한 부분이므로 0으로 모두 채워준다. `Arrays.fill()`을 활용하였다.
- 1번부터 $N$번까지의 물건에 대해서 확인하며, `w` 즉 무게는 0부터 `K`로 올라가면서 체크한다.
- 만약, `w`가 `weight[i]`, 즉 `i`번째 물건의 무게보다 작다면, 바로 윗 칸, 즉 `i-1`번째 물건까지의 `w` 무게의 최대 가치 값을 그대로 불러온다.
- 크거나 같으면 그 물건을 가방에 담을 수 있으므로 계산을 진행한다.

> `dpTable[i-1][w-weight[i]] + value[i]`   
> - 현재 최대 무게에서 담을 물건의 무게 `weight[i]`를 뺀 값을 `dpTable`에서 가져온다.
> - 이때, `dpTable[i]` 에서 가져오게 되면 `i`를 중복 선택하게 되므로 `dpTable[i-1]`의 `[w-weight[i]]` 값을 가져옴을 주의한다.
> - 그 가치 값에서 `i`번째 물건 가치 값 `value[i]`를 더한 것.
> - 이것이 이전 물건까지의 해당 무게에 대한 가치 최댓값인 `dpTable[i-1][w]`보다 커야 그 값을 채택하여 저장한다. 아니면, 윗 칸의 값을 그대로 받아온다.

마무리는 `dpTable[N][K]`를 `return` 해주면 된다.

### 2차원 냅색 알고리즘의 구현 - main 메소드
```java
	...
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        K = Integer.parseInt(st.nextToken());

        dpTable = new int[N + 1][K + 1];
        weight = new int[N + 1];
        value = new int[N + 1];

        for (int i = 1; i <= N; i++) {
            st = new StringTokenizer(br.readLine());
            weight[i] = Integer.parseInt(st.nextToken());
            value[i] = Integer.parseInt(st.nextToken());
        }

        System.out.println(knapsack());
    }
}
```
여기도 크게 설명할 건 없고, 이미 거의 만들어질 건 다 만들어졌기 때문에 각각의 정보를 배열에 집어넣고 `knapsack()` 메소드를 호출하기만 하면 끝이다. 2차원 배열임에 유의하며 index 범위를 잘 조정해주는 것만 유의하자.

## 정리
0-1 냅색 문제(배낭 문제)는 잘 알려진 DP 문제이다. 그만큼 다이나믹 프로그래밍에 익숙하지 않다면 틀리기 쉽고, 무엇보다 2차원 냅색 알고리즘의 경우에는 특히 값 계산에 있어 많이 헷갈리거나 왜 저렇게 계산이 되어야 하는지 잘 모르겠는 경우도 많다. 그렇기 때문에 코드를 제대로 이해하는 것이 중요하다.
