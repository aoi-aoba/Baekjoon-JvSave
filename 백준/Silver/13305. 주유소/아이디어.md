# 아이디어
그때그때 최솟값을 반영해서 최소 비용만큼 기름을 채워서 다니면 되는게 아닐까?

## 문제 파악하기
어떤 나라에 $N$개의 도시가 있다. 이 도시들은 일직선 도로 위에 있다. 편의상 일직선을 수평 방향으로 두자. 제일 왼쪽의 도시에서 제일 오른쪽의 도시로 자동차를 이용하여 이동하려고 한다. 인접한 두 도시 사이의 도로들은 서로 길이가 다를 수 있다. 도로 길이의 단위는 km를 사용한다.

처음 출발할 때 자동차에는 기름이 없어서 주유소에서 기름을 넣고 출발하여야 한다. 기름통의 크기는 무제한이어서 얼마든지 많은 기름을 넣을 수 있다. 도로를 이용하여 이동할 때 1km마다 1리터의 기름을 사용한다. 각 도시에는 단 하나의 주유소가 있으며, 도시 마다 주유소의 리터당 가격은 다를 수 있다. 가격의 단위는 원을 사용한다.

예를 들어, 이 나라에 다음 그림처럼 4개의 도시가 있다고 하자. 원 안에 있는 숫자는 그 도시에 있는 주유소의 리터당 가격이다. 도로 위에 있는 숫자는 도로의 길이를 표시한 것이다. 

![](https://velog.velcdn.com/images/aoi-aoba/post/d8843193-a630-44a5-901d-8cc574284199/image.png)

제일 왼쪽 도시에서 6리터의 기름을 넣고, 더 이상의 주유 없이 제일 오른쪽 도시까지 이동하면 총 비용은 30원이다. 만약 제일 왼쪽 도시에서 2리터의 기름을 넣고(2×5 = 10원) 다음 번 도시까지 이동한 후 3리터의 기름을 넣고(3×2 = 6원) 다음 도시에서 1리터의 기름을 넣어(1×4 = 4원) 제일 오른쪽 도시로 이동하면, 총 비용은 20원이다. 또 다른 방법으로 제일 왼쪽 도시에서 2리터의 기름을 넣고(2×5 = 10원) 다음 번 도시까지 이동한 후 4리터의 기름을 넣고(4×2 = 8원) 제일 오른쪽 도시까지 이동하면, 총 비용은 18원이다.

각 도시에 있는 주유소의 기름 가격과, 각 도시를 연결하는 도로의 길이를 입력으로 받아 제일 왼쪽 도시에서 제일 오른쪽 도시로 이동하는 최소의 비용을 계산하는 프로그램을 작성하시오..

---

입력은 다음과 같이 표준 입력으로 주어진다:
- 첫 번째 줄에는 도시 개수를 나타내는 정수 $N$이 2 이상 10만 이하의 자연수로 주어진다.
- 다음 줄에는 인접한 두 도시를 연결하는 도로의 길이가 왼쪽 도로부터 $N-1$개의 자연수로 주어진다.
- 다음 줄에는 주유소의 리터당 가격이 왼쪽 도시부터 순서대로 $N$개의 자연수로 주어진다.
- 가장 왼쪽 도시부터 오른쪽 도시까지의 거리는 1 이상 10억 이하의 자연수이며, 리터당 가격은 1 이상 10억 이하의 자연수이다.

출력은 표준 출력으로 제일 왼쪽 도시에서 제일 오른쪽 도시로 가는 최소 비용을 출력하자.

## 방법 고안
잘 생각해보면, 그때그때 업데이트를 잘 한다면 금방 해결 가능한 일이다.

### 예시를 통해 직접 생각해보자
예제 1에서
```
4
2 3 1
5 2 4 1
```
이 경우에서 맨 처음에 출발하기 위해서는 5원의 기름을 넣어야 하는 것은 당연하다. 그러니까, $5 \times 2 = 10$은 필연적이다.
- 그 뒤에 있는 2원의 가격은 훨씬 저렴하다. 그러므로 여기에서는 2원을 넣는 것이 이득이다. $2 \times 3 =  6$을 넣는다.
- 다음 도시를 갔을 때, 4원은 현재 최소 가격인 2원보다 훨씬 비싸다. 그러므로, 여기에서는 '돌아간다'라고 생각하지 말고, **이전 도시에서 이미 이 부분까지 넣고 왔다**&ZeroWidthSpace;라고 생각해보자. 그러면, 2원인 도시에서 $2 \times 1 = 2$를 넣고 온 것이다.

그러면 마지막 도시까지 총 18의 비용으로 도착이 가능하다.

그러니까, 여기에서 중점적인 아이디어는 그때그때의 최솟값을 반영하여 그 최솟값의 비용으로 앞으로 갈 거리를 계속 나아간다는 것이다. 그때그때 도착하는 도시마다 최소의 비용을 체크하고, 그 비용이 현재 있는 도시 전까지의 비용 중 가장 최소일 때의 비용에 앞으로 갈 거리만큼을 곱해서 체크하는, **그리디 알고리즘** 방식을 채택할 수 있는 것이다.


### 그리디 알고리즘(Greedy Algorithm)
그리디 알고리즘은 매 순간 가장 좋아 보이는 선택을 반복해 문제를 해결하는 근사적 알고리즘이다. 항상 최적해를 보장하지는 않는다. 하지만, 계산의 속도가 빠르고 직관적이라는 장점이 있다.

이 문제에서는 이 방식이 통한다. 위에서 말했듯, 앞 도시의 비용이 어쨌는지는 생각하지 않고 그저 체크하고 바로 기름을 넣어버리면 되는 것이다. 어떤 도시에 도착했을 때 **이전의 최솟값보다 비싼 기름 가격**&ZeroWidthSpace;이 형성되어 있다면, 우리는 **이전의 최소 비용의 기름 가격인 도시에서 이 지역 분량까지 넣고 왔다**&ZeroWidthSpace;라고 생각하면 되는 것이고 이 문제에서 이 방식은 가장 효율적이고 간단한 방식으로 문제를 풀 수 있게 한다.


---

## 코드화
### 전체 코드
```java
import java.io.*;
import java.util.*;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        int N = Integer.parseInt(br.readLine());
        List<Integer> roadLenList = new ArrayList<>(), gasLiterCost = new ArrayList<>();

        StringTokenizer st = new StringTokenizer(br.readLine());
        for (int i = 0; i < N - 1; i++)
            roadLenList.add(Integer.parseInt(st.nextToken()));
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < N; i++)
            gasLiterCost.add(Integer.parseInt(st.nextToken()));

        long sum = 0, smallest = gasLiterCost.get(0);

        for (int i = 0; i < N - 1; i++) {
            if (gasLiterCost.get(i) < smallest)
                smallest = gasLiterCost.get(i);
            sum += smallest * roadLenList.get(i);
        }

        System.out.println(sum);
    }
}
```
생각보다 코드를 짜는 것은 매우 간단하다. 입력을 각각 받아와서, 앞에서부터 돌아가며 `for` 문을 구성하여
- 앞으로 갈 거리에 대해 지금까지 본 기름 가격 중 최솟값을 확인
- 만약 현재 도착한 도시가 최솟값이면 최솟값을 반영
- `sum`에 이 최솟값인 `smallest`를 갈 거리에 곱하여 더함

이 과정을 반복해서 출력하면 된다. 입력 범위 조건을 잘 보면, `int`로는 해결되기 어렵다는 것을 알 수 있다. `long` 사용하여 큰 수를 출력할 수 있게 하자.

## 정리
너무 복잡하게 생각하지 않아야 효율적인 방식을 고안할 수 있었던 문제.
