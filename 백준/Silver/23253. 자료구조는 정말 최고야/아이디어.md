# 아이디어
애드 혹 문제는 문제를 잘 읽고 특이점을 파악해서 잘 구현하는 것이 중요하다. 기존의 자료구조에 매달리려고 하지 말자.

## 문제 파악하기
찬우는 교과서 $N$권을 $M$개의 더미로 아무렇게나 쌓아뒀고 이 교과서를 정리하여 번호순으로 나열하려 하는데, 각각의 교과서는 1부터 $N$까지의 번호가 매겨져 있고 찬우는 각 더미의 맨 위 교과서만 꺼낼 수 있고 꺼낸 순서대로만 반드시 나열한다. 즉, 1, 2, 3, ..., $N$번 순서로 꺼내야만 한다.

- 첫째 줄에는 교과서의 수 $N$과 교과서 더미의 수 $M$이 20만 이하의 자연수로 주어진다.
- 둘째 줄부터 두 줄씩 하나의 더미를 설명하는 정보가 주어진다.
- 두 줄 중 첫 번째 줄에는 더미에 쌓인 교과서의 수 $k_i$가 주어진다.
- 두 줄 중 두 번째 줄에는 더미에 쌓인 교과서에 적힌 번호가 아래서부터 주어진다.
- 모든 교과서에는 1부터 $N$까지의 정수가 한 번씩만 등장함이 보장된다.

## 방법 고안
스택이라는 말에 너무 매몰되면 결국 이해할 수 없다.

스택 구조는 늘 맨 위에서부터 요소를 뽑아야 한다는 것을 기억해보자. 그러면 맨 위에서부터 책을 뽑았을 때 뽑으려는 모든 경우의 책들이 다 해당 더미의 맨 위에 있어야만이 올바른 정렬이 가능하다. 1번을 뽑을 때는 어떤 더미에든 1번이 맨 위에 있어야 하고, 2번을 뽑을 때는 1번을 제외한 상태에서 어떤 더미에든 2번이 맨 위에 있어야 하고, 3번을 뽑을 때는 1번과 2번을 제외한 상태에서 어떤 더미에든 3번이 맨 위에 있어야 하고... 위와 같은 방식을 반복해야 한다면 결국 '모든 더미는 위에서부터 오름차순 형태로 주어져야 한다'라는 조건을 만족해야 한다. 반대로 말하자면, '모든 더미는 아래에서부터 내림차순 형태로 주어져야 한다'라고 설명할 수 있다.

그 결과, 우리는 그냥 더미의 정보가 주어지는 부분에서 이 수들이 내림차순 형태로 주어지지 않는다면 바로 불가능한 경우로 보고 `No`를 출력해주면 된다. 그렇지 않고 모두 내림차순 정렬이 잘 되어 있다면 우리는 `Yes`를 출력할 수 있게 된다.

## 코드화
### 전체 코드
```JAVA
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int N = Integer.parseInt(st.nextToken()), M = Integer.parseInt(st.nextToken());
        boolean result = true;
        for (int i = 0; i < M; i++) {
            int len = Integer.parseInt(br.readLine());
            StringTokenizer books = new StringTokenizer(br.readLine());
            int init = Integer.parseInt(books.nextToken());
            for (int j = 1; j < len; j++) {
                int temp = Integer.parseInt(books.nextToken());
                if (init < temp) {
                    System.out.println("No");
                    return;
                } else init = temp;
            }
        }
        System.out.println("Yes");
    }
}
```
해당 더미의 맨 처음 값만 `init`으로서 받아오고, 그것과 계속 뒤의 숫자를 비교하면서 내림차순이 정확히 이루어지고 있으면 `init`을 비교한 숫자로 초기화하고 아니면 바로 No를 출력하고 `return`을 통해 코드를 아예 종료해버린다. 어차피 코딩테스트의 채점 방식은 입력을 아예 한 번에 주는 것이기 때문에 해당 입력을 뒤쪽에 더 받지 않아도 아무런 문제가 없다.

## 정리
애드 혹(Ad hoc) 태그는 특별한 목적을 위한 특별한 해결책을 의미하는 라틴어에서 유래된 것이라고 한다. 다른 일에는 적용할 수 없거나 일반화할 수 없는 해결책을 쓰는 것이라고 한다. 즉, 여러 가지 정석적이고 정형화된 알고리즘으로 푸는 것이 아니라 각 문제에 대한 특별한 아이디어를 찾아서 특이한 발상으로 풀 수 있는 문제인 것이다. 따라서 문제에 따라서는 단순 구현 문제 혹은 그리디/수학 문제로 귀결되기도 한다고 한다. 결국 문제를 잘 읽어보는 것이 중요한 것이다.

~~제대로 읽어보지 않았다면 아마 스택으로 이걸 직접 구현하고 있었을 것이다~~
