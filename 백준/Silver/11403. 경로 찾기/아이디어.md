https://csacademy.com/app/graph_editor/

# 아이디어
플로이드-워셜 알고리즘을 사용하는 것이 효과적인 경우는, 시간 복잡도인 $O(N^3)$을 통해 대략적으로 추론해볼 수 있다.

## 문제 파악하기
가중치 없는 방향 그래프 $G$가 주어질 때 모든 정점 $(i, j)$에 대해 $i$에서 $j$로 가는 길이가 양수인 경로가 있는지 없는지 구하자.

---

입력은 다음과 같이 주어진다:
- 첫째 줄에 정점 개수 $N$이 100 이하의 자연수로 주어진다.
- 둘째 줄부터 $N$개 줄에 그래프를 인접 행렬로 나타낸 것이 주어진다.
- $i$ 번째 줄의 $j$ 번째 숫자가 1인 경우는 $i$ 에서 $j$ 로 가는 간선이 존재한다는 뜻이고 0인 경우는 없다는 뜻이다.
- $i$ 번째 줄의 $i$ 번째 숫자는 항상 0으로 주어진다.

출력은 다음과 같이 진행한다:
- 총 $N$개 줄에 걸쳐 문제의 정답을 인접 행렬 형식으로 출력한다.
- 정점 $i$ 에서 $j$ 로 가는 길이가 양수인 경로가 있다면 $i$ 번째 줄의 $j$ 번째 숫자를 1로, 없으면 0으로 출력한다.

## 방법 고안
$N$의 값이 매우 작다. $O(N^3)$ 알고리즘도 통과한다!

### 플로이드-워셜 알고리즘 (Floyd-Warshall Algorithm)
그래프의 최단 거리 알고리즘 중 플로이드-워셜 알고리즘은 모든 노드 간에 최단 경로를 탐색한다는 특징을 가진 알고리즘이며, 음수 가중치의 간선이 있더라도 수행이 가능하다. 동적 계획법(Dynamic Programming)의 원리를 이용한 알고리즘 접근법인데, 시간 복잡도는 노드 수 $V$에 대하여 $O(V^3)$으로 처리된다.

플로이드-워셜 알고리즘의 핵심 원리는 **$A$ 노드에서 $B$ 노드까지의 최단 경로를 구했다고 가정했을 때, 최단 경로 위에 $K$ 노드가 존재한다면 그것을 이루는 부분 경로도 최단 경로라는 것**&ZeroWidthSpace;이다.

![](https://velog.velcdn.com/images/aoi-aoba/post/03473313-8a28-4da4-8e38-0b1dd4fdf3cf/image.png)

가령 위와 같은 그래프가 존재한다고 생각해보자. 그렇다면 여기에서 1번에서 5번까지 가는 최단 경로가 만약
> 1 → 3 → 4 → 2 → 5

의 경로로 나타난다고 생각해볼 때, 1번에서 2번을 가기 위한 최단 경로는 어떻게 가야 하는가? 여기에서 그냥 가중치가 적혀 있지 않다 보니, 1 → 2를 생각하기 쉬우나 우리는 1번에서 5번까지 가는 최단 경로를 알고 있다. 만약 1 → 2가 최단 경로였다면, 1 → 2 → 5가 최단 경로가 아니었을까?

그러니까, 위에서 설명했듯이 1번 노드에서 5번 노드까지의 경로를 우리가 조사해두었기 때문에 그 위에 있는 각각의 노드에 대한 최단 경로 역시 각 부분 경로가 최단 경로일 것이라는 것이다. 즉...

> 1번 노드에서 2번 노드의 최단 경로 : 1 → 3 → 4 → 2   
> 4번 노드에서 5번 노드의 최단 경로 : 4 → 2 → 5   

같은 경우로 위에서 구한 최단 경로의 부분 경로를 또 다른 최단 경로로 볼 수 있게 된다는 것이다. 즉, 이를 활용한다면...

$$\text{Dist}[\text{start}][\text{end}] = \text{Min}(\text{Dist}[\text{start}][\text{via}] + \text{Dist}[\text{via}][\text{end}], \text{Dist}[\text{start}][\text{end}])$$

라는 결과를 얻을 수 있게 된다. 시작점과 도착점까지의 거리를 구하고, 어떤 특정 경유지에 대한 시작-경유지 거리, 경유-도착점 거리를 구할 수 있을 때 둘 중 최솟값이 최단 경로가 된다는 것이다.

그리고 이것은 인접 행렬 표현 방식을 활용하여 구현이 가능하다. 어떤 그래프 $G$가 인접 행렬로 구현되어 있을 때, 자기 자신에 대한 거리는 0이며, 그 외에는 모두 $$\text{INF}$$ 값으로 저장해둔다. 그런 초기 상태에서 각 정점 간의 간선 관계를 행렬에 저장하고, 3중 for 문을 활용한다면 이를 해결할 수 있다. 자세한 코드는 아래를 참고하자. 이 문제에서는 '양수 거리 판단'이 중요하기 때문에, 물론 가중치를 감안하거나 자기 자신에게 도착하는 거리 0은 감안하지 않는다.

---

## 코드화
### 전체 코드
```java
public class Main {
    public static int n;
    public static int[][] dist;
    public static final int INF = 98764321;
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        n = Integer.parseInt(br.readLine());

        dist = new int[n+1][n+1];
        for (int i = 1; i <= n; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            for (int j = 1; j <= n; j++) {
                int temp = Integer.parseInt(st.nextToken());
                dist[i][j] = (temp == 0) ? INF : 1;
            }
        }

        for (int k = 1; k <= n; k++) {
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= n; j++) {
                    dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
                }
            }
        }

        StringBuilder sb = new StringBuilder();
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++)
                sb.append(dist[i][j] == INF ? 0 : 1).append(" ");
            sb.append("\n");
        }

        System.out.println(sb.toString());
    }
}
```
$\text{INF}$ 값은 솔직히 크게 문제가 되지 않으므로, 대강 설정해둔다. 나머지는 코드를 따라가면서 확인해보자. 먼저, `dist`라는 인접 행렬을 두어 1-based index를 활용해 거리를 표현한다. 그 과정에서 입력은 그냥 2중 for 문으로 받으면 되는데, 여기에서

```java
int temp = Integer.parseInt(st.nextToken());
dist[i][j] = (temp == 0) ? INF : 1;
```

이 두 줄의 용도는 입력에서 0은 간선이 존재하지 않는 경우, 1은 존재하는 경우이므로 이를 구별하여 존재한다면 가중치를 1로 대강 설정해두고, 아니라면 가중치를 INF로 두어서 확인하는 것이다. 원래대로라면 `i==j`의 경우도 처리해줘야 하나, 다시 말하지만 여기서는 **양수 거리** 만을 확인할 것이므로 자기 자신에 대한 0 거리는 저장하면 안 된다.

그런 다음, 3중 for 문이 드디어 나오게 된다.
```java
for (int k = 1; k <= n; k++)
	for (int i = 1; i <= n; i++)
    	for (int j = 1; j <= n; j++)
			dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);
```

구조는 매우 단순하다. 위에서 설명했던 방법대로, 경유지 인덱스 `k`와 특정 지점 확인을 위한 `i`, `j`를 활용하여 `i`에서 `j`까지 가는 거리는 기존에 가지고 있던 경로와 `i`에서 경유지를 갔다가 `j`까지 가는 거리 중 최소 거리이다라는 의미로 인접 행렬의 값을 갱신하는 것.

이렇게 하게 된다면, 양수 거리를 제외한 경우는 모두 INF로 처리된다.

> 여기에서, 0인 거리 역시 그러하다. 이는 예제 입출력 2를 확인하면 되는데, 원래대로라면 자기 자신에게 도착하는 거리는 0이기 때문에 '도착할 수 있다'라는 의미로 분류하는 것이 최단 경로 알고리즘에서는 맞으나 여기에서 문제는 **길이가 양수인 경로가 있는지** 여부를 판단하라고 하였다. 그래서 출력 부분에 `i`와 `j`가 인덱스가 서로 같은 자기 자신에게 가는 부분이 0인 경우도, 1인 경우도 있음을 알 수 있다.

그러면 이제 그냥 쭉 돌면서, `INF`인 경우만 제외하고 나머지는 모두 1로 출력하고 `INF`는 0으로 출력해주면 된다.

## 정리
BFS나 DFS로도 충분히 구현할 수 있을 것이다. (실제로 그런 의도로 냈을 가능성도 배제할 수 없고, 그 풀이에 대한 이야기도 올라와 있다.) 하지만 태그에도 플로이드-워셜이 적혀 있고 무엇보다 시간 복잡도 자체가 그렇게 커지지 않고 문제의 조건 자체가 naive하게 $O(N^3)$을 써도 된다는 방식으로 제시해주는 느낌이기 때문에 플로이드-워셜 알고리즘을 알고 있다면 사용하는 것이 가장 효과적이지 않았을까.
