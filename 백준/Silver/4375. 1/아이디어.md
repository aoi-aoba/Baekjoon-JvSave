# 아이디어
모듈러 연산을 조금만 생각해본다면 간단히도 풀 수 있었다.   
뭐 그렇다고 해서 내가 푼 방식이 멍청하다고는 생각하지 않는다.   
다 풀고 나서 이걸 적으면서 문제의 전제조건을 이해하는 데 시간을 더 많이 쓴 것 같기도 하다.

## 문제의 전제조건
이 문제가 성립할 수 있다는 것을 전제하기 위하여 두 가지 수학 개념을 설명하겠다.   
**오일러 피 함수(Euler’s phi (totient) function)와 오일러의 정리(Euler's theorem)**&ZeroWidthSpace;가 필요하다.

### 🖋️ 오일러 피 함수란?
> 어떤 자연수 $$n$$에 대하여 $$n$$보다 **작거나 같은 자연수** 중 $$n$$과 **서로소인 수의 개수**&ZeroWidthSpace;를 함숫값으로 가지는 함수이다. 

피(phi, $$φ$$) 기호를 사용해서 $$φ(x)$$라고 쓴다.
- 1~6에서 6의 소인수는 1과 5이므로 $$φ(6) = 2$$
- 1~11에서 11의 약수는 1과 11이므로 $$φ(11) = 10$$  

특수성을 활용하면 소수인 $$x$$에 대하여 $$φ(x) = x - 1$$이 성립한다.

### 🖋️ 오일러의 정리
> 자연수 $$n$$과 $$a$$가 서로소이면 $$a^{φ(n)}$$을 $$n$$으로 나눈 나머지는 1이다.

#### ☑️ 증명
집합 $$S = \{b_1, \cdots , b_{φ(n)}\}$$를 $$n$$ 이하의 자연수 중 $$n$$과 서로소인 수만 모은 집합으로 하자.   
오일러 피 함수의 정의에 의해 원소 개수는 $$φ(x)$$이다.   
집합의 각 원소 모두에 ($$n$$과 서로소인) $$a$$를 곱한 집합을 구하면 이 집합을 $$aS$$라고 할 때 $$aS = \{ab_1, \cdots , ab_{φ(n)}\}$$이다.   
이때 집합 $$aS$$의 모든 원소는 $$n$$과 서로소인 수들끼리 곱했기 때문에 그들 역시 모두 서로소이다.

---

집합 $$aS$$의 원소 중 $$ab_i$$와 $$ab_j$$가 $$n$$에 대한 모듈러 연산을 진행했을 때 같다고 가정해보자.
그러면 1 이상 $$φ(n)$$ 이하인 서로 다른 정수 $$i, j$$가 존재한다는 것이므로 $$a(b_i - b_j)$$ 역시 $$n$$의 배수이다.   
그런데, 우리는 이미 위에서 집합 $$S$$에 대해 $$n$$과 서로소인 $$a$$를 곱했다.
그러므로 $$a(b_i - b_j)$$에서 $$n$$의 배수인 부분은 $$b_i - b_j$$이다.
$$b_i$$와 $$b_j$$는 처음의 집합 $$S$$의 성질에 의하여 1 이상 $$n$$ 이하의 자연수라고 할 수 있다.
이를 이용하면 $$-(n-1) ≤ b_i - b_j ≤ n-1$$이라는 범위가 나온다.  ($$1-n$$을 가독성을 위해 $$-(n-1)$$로 쓴다)
그러나 이 범위 내에서 $$n$$의 배수가 되게 하려면 값이 0밖에 없다.   
결과적으로 집합 $$aS$$의 모든 원소는 $$n$$으로 나눈 나머지가 서로 다르다.

---

위에서 증명한 것을 바탕으로 했을 때 $$aS$$의 모든 원소들을 $$n$$으로 나눈 나머지는 $$S$$의 원소들을 재배열한 것과 같다.
위 과정을 통해 우리는 $$S$$의 모든 원소의 곱과 $$aS$$의 모든 원소의 곱이 $$n$$으로 나눈 나머지가 같음을 알 수 있다.
이는 $$b_1 \cdots b_{φ(n)} = a^{φ(n)}b_1 \cdots b_{φ(n)}\pmod{n}$$ 이다.
따라서, $$a^{φ(n)}≡1\pmod{n}$$임을 증명할 수 있다.


### 🖋️ 문제의 전제조건 설명
문제로 돌아와서, 문제에서 판별할 1로만 이루어진 자연수를 $$N_k$$라고 하자.
그러면 $$N_k = \frac{10^n - 1}{9}$$라고 둘 수 있다.
이때 문제 조건에서 우리에게 주어지는 수는 2와 5로 나누어떨어지지 않는 수만이 주어진다.
즉, $$n$$이라는 수는 **10에 대하여 서로소임이 이미 입증되어있는** 셈이다.
여기서 **페르마-오일러 정리를 활용하면** 자연수 n과 10이 서로소이므로 $$10^{φ(n)}≡1\pmod{n}$$
$$φ(n) = k$$라고 하면 식으로 정리했을 때 $$10^k = 1\pmod{n}$$이라고 정리할 수 있다.
이때 $$(10^k - 1)\bmod{n}$$이라고 하면 **모듈러 연산의 분배법칙**&ZeroWidthSpace;이 성립한다.   
$$(10^k \bmod{n})- (1 \bmod{n}) = 0$$이 되어 이 과정에서 $$10^k - 1 = 0\pmod{n}$$임이 자명하다.
이 값을 9로 나누게 되어도 $$\frac{10^k - 1}{9} = 0\pmod{n}$$이 일반성을 잃지 않는다.
동시에 $$φ(n)$$이라는 함수 자체는 정의에서부터 n보다 작은, 즉 $$p(n) < n$$임이 보장된다.
따라서 자릿수를 1부터 $$n$$까지 늘리는 동안에 $$n$$의 배수는 적어도 하나 나오게 된다.

## 오히려 문제의 전제조건보다 문제가 더 쉽다
결과적으로 우리가 할 것은 몇 자리의  $$N_k$$가 $$n$$의 배수냐는 것이므로, 직접 값을 올려가면서 계산해보면 된다. 다만, 확정적으로 값의 범위에 의해 결과값은 `int`와 `long` 범위는 초과할 것임이 보장되어 있다. 그렇기에 두 가지 방법을 제시할 수 있다.

### 🫢 java의 BigInteger를 사용하는 방법
이게 내가 푼 방법인데, 코드의 설명은 아래에 달겠다.

```JAVA
	String str = br.readLine();
        while(str != null) {
            int n = Integer.parseInt(str);
            if(n == 1) System.out.println(1);
            else {
                BigInteger result = new BigInteger("1");
                while(true) {
                    result = result.multiply(BigInteger.TEN).add(BigInteger.valueOf(1));
                    if (result.remainder(BigInteger.valueOf(n)).compareTo(BigInteger.ZERO) == 0)
                        break;
                }
                System.out.println(String.valueOf(result).length());
            }
            str = br.readLine();
        }
```
- 우선 값을 받아와서 `EOF`가 되기 전까지 `while`문으로 testcase를 모두 돌린다.
- n이 1인 경우에 답은 1이므로 바로 출력해주자.
- 아닌 경우에는 $$N_k$$를 저장할 `BigInteger result`를 하나 선언해주자.
- 이 값을 10을 곱하고 1을 늘리는 방식으로 계속 한 자리씩 늘려나간다.
- 그리고 `BigInteger.remainder()` 메소드를 활용하여 나머지가 0이면 `break`로 빠져나간다.

### 😆 굳이 저럴 필요 없이 그냥 모듈러 연산의 특징을 활용하는 방법
다 풀고 나서 알아보다가 생각난 방법인데, 코드의 설명은 여전히 아래에 있다.
```JAVA
while(true) {
	int n = Integer.parseInt(br.readLine());
    int cnt = 1;
    int prev = 1;
    while ((prev = prev % n) != 0) {
    	cnt++;
        prev = prev * 10 + 1;
    }
    System.out.println(cnt)
}
```
- 모듈러 연산은 기본적으로 덧/뺄셈과 곱셈에 대한 분배법칙이 성립한다.
- 그러므로, 10+1을 계속 진행하면서 그 횟수를 `cnt`에 더해준다. 초기값은 1의 길이인 1이다.
- 그리고 안쪽 `while` 문에서 `n`에 대한 모듈러 연산을 실행하면서 0이 되면 이를 중단하자.
