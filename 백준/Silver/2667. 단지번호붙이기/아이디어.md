# 아이디어
DFS 혹은 BFS를 활용하여 이차원 배열을 돌아보는 것이 핵심이다. dx-dy technique를 사용하자.

## 문제 파악하기
![](https://velog.velcdn.com/images/aoi-aoba/post/ab894a9d-121e-4357-8287-c843033e8d3d/image.png)

정사각형 모양의 지도가 <그림 1>처럼 주어질 때, 1은 집이 있는 곳, 0은 집이 없는 곳이다. 이 지도를 가지고 연결된 집의 모임인 '단지'를 정의하고 단지에 번호를 붙인다. 연결되었다는 것은 좌우 혹은 상하로 다른 집이 있는 경우이다. 그러면 <그림 2> 처럼 될 수 있다. 이렇게 지도를 입력해 단지수를 출력하고 각 단지의 집의 수를 오름차순으로 정렬하는 프로그램을 작성하자.

---

입력은 다음과 같이 주어진다:
- 첫 번째 줄에는 지도 크기 $N$이 5 이상 25 이하의 자연수로 주어진다.
- 지도는 정사각형이므로 가로와 세로의 크기가 같다.
- 그 다음 $N$개 줄에 대해 각각 $N$개의 자료가 0 혹은 1로 주어진다.

출력은 첫 번째 줄에는 총 단지수를, 그리고 그 아래 각 단지 내 집의 수를 오름차순으로 정렬하여 한 줄에 한 단지씩 출력하자.

## 방법 고안
BFS나 DFS를 사용하여 지도를 돌아보는 것이 중요하다.

### 이차원 배열의 순회
이차원 배열을 순회하는 방법은 아무래도 이중 for 문으로 도는 것이지만, 여기에서는 인접한 '단지'를 구분하는 동시에 돌아야 한다는 것이 중요하다. 

어느 지점을 기준으로 하여, 주변의 단지를 판단하려면 어떻게 해야 할까? 상하 혹은 좌우로 인접해야 단지이기 때문에 우리는 해당 좌표를 $(x, y)$라고 두었을 때 $(x-1, y)$, $(x, y-1)$, $(x+1, y)$, $(x, y+1)$을 둘어봐야 한다는 것을 알 수 있다. `dx[]` 및 `dy[]`의 배열을 통하여 $x$와 $y$의 변화값을 저장하고 순회하는 방식으로 확인해보도록 할 수 있겠다. (dx-dy technique라고도 불린다)

### 너비 우선 탐색과 깊이 우선 탐색
우선, BFS에 대하여 생각해보자. 너비 우선 탐색은 그래프 상에서도 한 정점으로부터 나아갈 수 있는 다른 정점을 모두 생각해보고, 그것을 차례차례 순회하는 방식이었다. 그렇다면, 네 개 방향(상하좌우)에 위치한 곳을 각각의 정점으로 간주한다면 비슷한 방식으로 순회가 가능할 것이다. **즉 Queue 구조를 활용하여 순회하는 것을 사용**&ZeroWidthSpace;한다면 일반적인 BFS를 사용하는 것과 동일하게 풀 수 있을 것이다.

DFS는 어떨까? 깊이 우선 탐색은 그래프 상에서, 한 정점으로부터 나아갈 수 있는 대로 쭉쭉 뻗어나가서 더 이상 나아갈 수 없으면 다시 돌아오는 방식을 택한다. 그러면, 어떤 한 지점에 대하여 계속 dx-dy technique를 사용하여 **나아갈 수 있는 인접한 단지로 계속 뻗어나가 더 이상 그것이 네 개 방향 어디로도 불가능한 상황**&ZeroWidthSpace;까지 나아가면 한 개의 단지를 찾을 수 있을 것이다. **방문한 곳을 다시 가지 않아도 된다는 점**&ZeroWidthSpace;에서 이 반복이 끝나는 지점은 명료하다.

![](https://velog.velcdn.com/images/aoi-aoba/post/e4960e94-8842-4544-86de-de0c742828ee/image.png)

즉, 너비 우선 탐색은 위의 그림처럼 각 위치에 대하여 갈 수 있는 모든 경로를 Queue 구조를 활용하여 그래프에서의 알고리즘 분석처럼 뻗어나가는 모양이 그려지고, 깊이 우선 탐색의 경우는 한 위치에서 갈 수 있는 곳을 계속 쭉 넘어가다가 더 이상 갈 수 없으면 재귀 함수처럼 뒤로 다시 돌아가 쭉쭉 뻗어나가는 방식으로 넘어가면 된다.

---

이와 같은 방식으로 코드를 구현하면 되겠다. 아래에서는 BFS와 DFS의 코드를 모두 구현해보려고 한다.

## 코드화
### BFS를 활용하기 위한 메소드 구조
```java
public class Main {
    public static int[][] map;
    public static boolean[][] check;
    public static int[] dx = {0, 0, -1, 1};
    public static int[] dy = {-1, 1, 0, 0};
    public static int n;

    public static int bfs(int startX, int startY) {
        Queue<int[]> Q = new ArrayDeque<>();
        Q.offer(new int[]{startX, startY});
        check[startY][startX] = true;
        int cnt = 1;

        while (!Q.isEmpty()) {
            int[] cur = Q.poll();
            int x = cur[0], y = cur[1];

            for (int i = 0; i < 4; i++) {
                int nx = x + dx[i], ny = y + dy[i];
                if (nx >= 0 && nx < n && ny >= 0 && ny < n && map[ny][nx] == 1 && !check[ny][nx]) {
                    check[ny][nx] = true;
                    cnt++;
                    Q.offer(new int[]{nx, ny});
                }
            }
        }

        return cnt;
    }
```

지도를 `map[][]`의 2차원 배열로 받아오고, 이 곳에서 이미 확인한 곳은 `check[][]`의 2차원 배열에 저장한다. dx-dy를 돌아볼 수 있게 배열을 지정하고, 크기 $N$은 전역으로 선언한다.

일반적인 `bfs` 알고리즘과 비슷한 방식으로 돌 수 있다.
- `bfs(int startX, int startY)`의 형태로 parameter로 주어지는 최초 시작 지점을 기준으로 Queue를 만들어서 이 안에 최초 지점을 삽입하고 최초 지점을 `true`로 바꾼다.
- Queue가 `isEmpty()`를 통해 비어있지 않은 동안, 좌표를 하나씩 꺼내어 순회한다. 이 지점을 각각 `x`, `y`라는 변수에 좌표를 지정한다. 그리고 for 문을 이용해 이동한 `nx`, `ny`의 값을 구한다.
- 해당 값이 '범위 내에 존재'하는지, 그리고 집이 있는(값이 1인) 곳인지, 그리고 이미 본 곳은 아닌지 체크한 다음, 만약 그게 모두 맞다면 `true`로 바꾸고 `cnt`를 1 증가시키며 Queue에서 살펴볼 곳으로 값을 뒤에 추가한다.
- 앞에서부터 값을 계속 돌면서 체크하면 된다.

모두 돌았다면, `cnt` 값을 `return`한다.

### DFS를 활용하기 위한 메소드 구조
```java
public class Main {
    public static int[][] map;
    public static boolean[][] check;
    public static int[] dx = {0, 0, -1, 1};
    public static int[] dy = {-1, 1, 0, 0};
    public static int n, space = 1;

    public static void dfs(int x, int y) {
        check[y][x] = true;
        for (int i = 0; i < 4; i++) {
            int nx = x + dx[i], ny = y + dy[i];
            if (nx >= 0 && nx < n && ny >= 0 && ny < n && map[ny][nx] == 1 && !check[ny][nx]) {
                space++;
                dfs(nx, ny);
            }
        }
    }
```

위쪽에서 전역으로 선언하는 것은 거의 같으나 `space`라는 전역 변수를 하나 추가했다. 이는 `dfs` 메소드를 재귀를 사용하기 위해서이다.

일반적인 `dfs` 알고리즘과 비슷한 방식으로 돌 수 있다.
- `dfs(int x, int y)`의 형태로  parameter로 주어지는 최초 시작 지점을 기준으로 `check[y][x]`를 확인했다고 `true`로 변경한다.
- 그리고, 위에서 사용했듯 네 개 방향의 지점을 확인하고, 만약 조건이 맞다면 `space`를 1 증가시키고, 바로 해당 지점으로 이동해버린다.
- 이런 방식으로 나아가다가 도중에 막히는 곳이 발생한다면 재귀를 역으로 돌아오면서 더 나아갈 수 있는 지점이 있었는지 for 문을 통해 확인하는 백트래킹과 유사한 과정을 거칠 것이므로  전체 단지를 돌 수 있게 된다.

### BFS와 DFS의 main 메소드
```java
	...
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        n = Integer.parseInt(br.readLine());
        map = new int[n][n];
        check = new boolean[n][n];

        ArrayList<Integer> list = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            String temp = br.readLine();
            for (int j = 0; j < n; j++) {
                map[i][j] = temp.charAt(j) - '0';
            }
        }
```

값을 변수들로 받아들이고 map에 값을 입력받는 부분이다. 이 부분은 DFS든 BFS든 모두 같다.

```java
		...
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (map[i][j] == 1 && !check[i][j]) {
                    dfs(j, i);
                    list.add(space);
                    space = 1;
                }
            }
        }

        Collections.sort(list);
        bw.write(list.size() + "\n");
        for (int spaceSize : list) bw.write(spaceSize + "\n");
        bw.flush();
    }
}
```
DFS의 구조에서는 전체 map을 돌면서, 값이 1인 동시에 이미 본 곳이 아닌 곳을 if 문을 통해 걸러낸 다음, `dfs(j, i)`를 호출한다. 그러고 나면 전체 단지를 한 번 돌고 나서 `space`의 값이 바뀌어 있을 것이기 때문에(전역 변수이므로) `list.add(space)`를 통해 값을 저장하고 `space`를 1로 다시 바꾸어준다.

그 뒤에 오름차순 정렬을 위해 `Collections.sort()`를 사용해주고, 값을 출력 형식대로 출력해주기만 하면 된다.

```java
		...
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (map[i][j] == 1 && !check[i][j]) {
                    int spaceSize = bfs(j, i);
                    list.add(spaceSize);
                }
            }
        }

        Collections.sort(list);
        bw.write(list.size() + "\n");
        for (int spaceSize : list) bw.write(spaceSize + "\n");
        bw.flush();
    }
}
```
BFS의 구조에서는 살짝 달라지는 것이, `int` 값을 직접	 `return`하기 때문에, 그 값을 `list.add(spaceSize)`로 넘겨주는 것이 달라질 뿐, 나머지는 같다.

## 정리
재귀 깊이가 깊으면 스택 오버플로우의 위험을 가지는 DFS (Java는 특히 1,000~10,000 깊이에서 위험하다) 구조는 구현이 간단하고 직관적이다. 반면, BFS는 DFS에 비해 구현이 어렵지만 큐를 사용하기 때문에 재귀 깊이 문제가 발생하지 않으며 같은 레벨(거리)를 순회하는 것에 유리하다.
