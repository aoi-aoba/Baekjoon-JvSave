# 아이디어
조금 더 편한 방법이 있을지?는 모르겠는데, 일단 실버 난이도에서는 이정도가 최선일 것 같아보인다. 다른 방법이 있나 찾아봤는데 몇 개 봤는데 다 비슷한 방식이라서...

## 문제 파악하기
되게 단순한 문제다.   
10만 이하의 자연수로 주어지는 A와 B, 100만 이하의 자연수로 주어지는 N이 주어진다.   
우리는 A를 B로 나눈 값을 소수로 나타내어 소수점 아래 N번째 자릿수의 값을 출력하면 된다.

## 방법 고안
좀 여러가지 생각을 해본 것 같다.   

1. 일단은 그냥 나눗셈을 쓰면 안 될거다    

그러라고 낸 문제도 아니겠지만, 소수점 아래 100만 번째 자리를 누가 자료형으로 구할 수 있게 해놨겠는가? 그러면 몫만 챙기는 방식으로 나눗셈을 **직접 구현하는 것이** 옳은 방법이 아닐까?

2. 시간 복잡도를 감안해봤을 때 괜찮아야 한다

2초라는 시간이 주어지기는 하지만, N이라는 것이 100만이므로 뭔가를 할 때 `for` 문은 한 번 정도가 최선으로 사용할 수 있다고 생각했다.

3. (사용하지 않음) 순환소수는 100만을 구할 필요가 있나?

수학적 개념을 잠깐 도입해보자.
> 순환소수는 분모가 9로만 이루어진 숫자로 나타낼 수 있다.
가령, 0.123123... 처럼 순환마디가 123인 경우에는 123/999로 나타낼 수 있다.
1.477777... 처럼 나타나는 경우는 (147-14)/90 처럼 나타낼 수 있다.

그렇다면 이런 경우에서 볼 수 있듯이 9와 0으로 나타낼 수 있는 수들의 약수이면 우리는 순환소수로 나타낼 수 있는 것이 아닌가라는 생각을 할 수 있다.

## 일단 통과한 방식
아무리 그렇다고 해도 순환마디를 구하는 방식이 생각보다 번거롭기도 하고 어차피 그렇지 않은 경우는 구할 수밖에 없다는 것을 알 수 있다.

```JAVA
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int A = Integer.parseInt(st.nextToken()), B = Integer.parseInt(st.nextToken());
        int N = Integer.parseInt(st.nextToken()), res = 0;

        A %= B; // A의 초기값을 세팅 (자연수 범위는 필요가 없으니까)
        for(int i=1; i<=N; i++) {
            A *= 10;
            if(i == N) res = A / B;
            else A %= B;
        }

        System.out.println(res);
    }
}
```

말 그대로 값을 받아오고, 일단 소숫점 아래 부분이 아닌 경우는 필요 없으니 초기값을 **A를 B로 나눈 나머지로** 설정한다. 그 상태에서 처음 세로 나눗셈을 배울 때처럼, 0을 붙이고 나누고 나머지를 구하고 하는 방식을 구현해준다.
- i가 N번째에 도달한 경우만 몫을 구한다.
- 아닌 경우는 몫을 구하면서 메모리 낭비 조금이라도 할 필요도 없다.
- 즉, A의 끝에 0을 붙인(10을 곱한) 뒤 A를 B로 나눈 나머지를 계속 구한다.

시간 복잡도도 생각해보면 결국 $$O(N)$$인데, 2초니까 100만 정도는 아무런 문제도 없고 단순 연산을 반복하다 보니까 특별히 걸릴 일은 없었던 것 같다.

## 여담
조금 더 생각해보자. 모든 유리수는 순환소수 혹은 순환하지 않는 유한소수로 나타낼 수 있다. 이는 자명한 사실이다. 사실 그렇다고 한다면 우리가 그 어떤 값을 준다고 해도 순환마디는 존재하게 될 것이다.

1/7은 142857이 반복되는 형태라서 잘 알려져 있다. 근데 생각해보니 위에서 적었던 것과 살짝 다른 점이 있다. 설령 9990, 99999 이런 형식으로 나타내지 않더라도, 그니까 우리가 굳이 그걸 세팅해서 분모로 바꿔주지 않더라도 나눗셈을 하다가 순환마디를 구하면 그만이다. 다만 이걸 찾아내는 것이 언제가 될지 모르기 때문에 그런 것이다.

가령, 소수인 17로 1을 나누게 된다면 0.0588235294117647...인데, `0588235294117647
`이라는 부분 전체가 순환마디이다. 그러니까, 저 순환마디를 체크하면서 하는 것 자체가 너무 불필요한 작업은 아닐까 하는 생각도 든다.

구현은 가능하겠으나... 순환하지 않는 소수에 대해서는 굳이 또 저런 과정이 필요없는 것이니까.
