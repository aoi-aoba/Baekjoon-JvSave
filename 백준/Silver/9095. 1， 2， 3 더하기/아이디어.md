# 아이디어
다이나믹 프로그래밍의 아이디어 정도를 테스트해볼 수 있는, 사실상 문제 해결의 아이디어가 더 중요한 문제

## 문제 파악하기
정수 4를 1, 2, 3의 합으로 나타내는 방법은 다음과 같이 총 7가지가 있다.
> 1+1+1+1, 1+1+2, 1+2+1, 2+1+1, 2+2, 1+3, 3+1

위의 예시와 같이 합을 나타낼 때는 수를 1개 이상 사용해야 한다. 1 2개와 2 1개를 사용한 값 3가지가 모두 각각 1가지로 인용되는 것을 보면 알겠지만, 순서가 바뀌면 다른 가지수로 간주한다. 이때 정수 n이 주어지면 1, 2, 3으로 n을 나타내는 방법을 구해 출력하자.

- 첫째 줄에 테스트 케이스 개수 `T`가 주어진다.
- 둘째 줄부터 11보다 작은 양수 `n`이 주어진다.

## 방법 고안
직접 몇 개 써보는 게 도움이 된다.
> **1을 만드는 방법** : 1 (1가지)   
> **2를 만드는 방법** : 1+1, 2 (2가지)   
> **3을 만드는 방법** : 1+1+1, 2+1, 1+2, 3 (4가지)

그러면, 여기에서 4를 만드는 방법을 다시 한 번 생각해보자. 1, 2, 3을 사용할 수 있을 때 우리는 1에 3을 더해야 하고, 2에 2를 더해야 하고, 3에 1을 더해야 그 값을 만들 수 있다. 즉,
> **1을 활용하여 4를 만드는 방법** : 1+3
> **2를 활용하여 4를 만드는 방법** : 1+!+2, 2+2
> **3을 활용하여 4를 만드는 방법** : 1+1+1+1, 2+1+1, 1+2+1, 3+1

다음과 같은 방법으로 만들어짐을 알 수 있고 점화식 형태로도 충분히 나타낼 수 있게 된다.

$N_i = N_{i-3} + N_{i-2} + N_{i-1}$

그러므로 bottom-up을 활용하여 Dynamic Programming으로 구현한다면 금방 답을 도출할 수 있을 것이다. 범위도 좁아서 정말 금방 끝난다.

## 코드화
### DP 테이블 구현
```JAVA
public class Main {
    public static int[] arr;
    public static void setArr() {
        arr = new int[12];
        arr[1] = 1; arr[2] = 2; arr[3] = 4;
        for (int i = 4; i < 12; i++)
            arr[i] = arr[i-3] + arr[i-2] + arr[i-1];
    }
```
말 그대로 1, 2, 3일때의 경우만 각각 1가지, 2가지, 4가지인 것으로 할당해주고 4부터 배열 뒤쪽까지 진행해줬다. 위에서 찾아낸 점화식으로 그냥 쭉 배열 값을 만들어주면 된다.

### main  구현
```JAVA
		public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();
        int N = Integer.parseInt(br.readLine());
        setArr();
        while (N-- > 0) sb.append(arr[Integer.parseInt(br.readLine())]).append("\n");
        System.out.print(sb);
        br.close();
    }
}
```
이제 맨 위에서 `N` 값을 받아서 배열에서 값을 확인하며 출력하면 된다.

## 여담
시간 복잡도는 어렵지 않게 while 문에 의하여 $O(N)$임을 알 수 있다. 물론 DP 테이블에도 for 문은 쓰이긴 하지만 사실상 크게 의미 없긴 하니까.

