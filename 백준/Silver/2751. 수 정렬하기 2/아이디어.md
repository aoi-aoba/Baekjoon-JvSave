# 아이디어
여기에서는 '아이디어'라기 보다는 정렬 알고리즘에 대한 이야기를 하려 한다.

## JAVA의 정렬 알고리즘
알아본 결과, 이 문제에서 원래 Arrays.sort()를 사용하면 시간초과가 발생한다고 한다.

그 이유는 Arrays.sort()는 dual pivot Quick Sort를 사용하는데, 일반 Quick sort와 달리 2개 피벗을 사용해 세 부분으로 나눈다.
퀵 정렬보다 당연히 속도는 빨라질 수밖에 없고, 다만 값의 비교와 이동이 굉장히 빈번해진다.
원시 타입(primitive type : int[], long[] array) 배열의 정렬에 사용되는데 다만 이 경우도 시간 복잡도는 O(n log n), 최악의 경우 O(n^2)으로 나타난다.

JAVA의 Collections.sort()는 Tim Sort를 사용한다. Tim sort는 삽입 정렬과 병합 정렬의 강점을 결합한 형태이다. 삽입 정렬의 작은 데이터 세트에 대해 효율적인 면과 병합 정렬의 큰 데이터 세트에 효율적인 면을 합친 것이다.
배열을 일단 여러 부분으로 나누어 run이라고 부르며, 각 run에서는 삽입 정렬을 사용하여 정렬한다. 정렬된 run을 다시 병합 정렬로 합치면서 정렬한다.
시간 복잡도는 평균적으로도, 최악으로도 O(n log n)으로 일정한 성능을 보이며 이미 정렬된 데이터 세트에 대해 더 빠른 속도를 낸다.
다만, 구현이 상대적으로 어렵고 추가적인 메모리가 병합 과정에서 필요하며 작은 데이터셋에서는 다른 정렬 알고리즘이 효율적일 수 있다.

그리고 사용 가능한 정렬이 Counting Sort(계수 정렬)이다. 비교를 하지 않는 정렬 방법 중 하나로, 주어진 배열 내 요소가 몇 번 등장하는지 세어 정렬하는 방식이다.
정수나 특정 범위 내 값을 가지는 데이터에 대해 매우 효율적이며 특히 작은 범위의 정수 정렬에 높은 성능을 보인다. 아이디어는 입력 배열의 각 요소가 배열 내에서
몇 번째 위치해야 하는지를 직접 계산하는 방식이다. 계수 정렬의 단계는 아래와 같다:

1. 입력 배열의 요소 범위 확인: 입력 배열에서 가장 큰 요소를 찾아 그 값을 기반으로 카운트 배열의 크기를 결정합니다.
2. 카운트 배열 초기화 및 데이터 세기: 모든 요소를 세어 해당하는 인덱스의 카운트 배열 값을 증가시킵니다.
3. 누적 카운트 배열 계산: 카운트 배열을 순차적으로 더해, 각 요소가 출력 배열에서 몇 번째 위치에 있어야 하는지를 결정합니다.
4. 결과 배열 만들기: 입력 배열을 반복하며, 카운트 배열을 참조하여 각 요소를 결과 배열의 올바른 위치에 배치합니다.
5. 결과 복사: 결과 배열의 내용을 입력 배열에 복사합니다(필요한 경우).

계수 정렬은 데이터 범위가 한정적이고 크기가 크면 매우 빠르며, 동일 값 요소 사이 상대적 순서가 유지된다. 시간 복잡도는 O(n+k)로, n은 배열 크기, k는 입력 데이터 범위이다.
다만, 데이터 범위가 넓어질수록 그 효율성이 떨어지기 때문에 조심해야 한다. 그럼에도 불구하고 특정 상황에서 다른 정렬 알고리즘보다 월등하게 빠른 성능을 보인다.
(출처 : https://wikidocs.net/233715)

## 정확한 분석
출처 : https://cafe.naver.com/muhansacomunity/360?art=ZXh0ZXJuYWwtc2VydmljZS1uYXZlci1zZWFyY2gtY2FmZS1wcg.eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjYWZlVHlwZSI6IkNBRkVfVVJMIiwiY2FmZVVybCI6Im11aGFuc2Fjb211bml0eSIsImFydGljbGVJZCI6MzYwLCJpc3N1ZWRBdCI6MTc0MDY3MjQzNzY1N30.QtHl3tRXYF7SeJ9i_WE_wkK_NxIF-MgaC-yoF6jUNdA

N의 범위가 100만까지이므로 O(n^2) 알고리즘을 사용하면 시간이 오래 걸린다. 제약조건 없이 빠른 알고리즘을 쓰려면 퀵/병합/힙 정렬이 사용 가능하다.
다만, 퀵 정렬은 최악의 상황에서의 시간복잡도 O(n^2)가 나타나는 '역순 수 배열'이 예제에서부터 케이스로 제공되기 때문에 시도할 시 시간 초과가 발생한다.
여기서는 그래서 파이썬의 경우 sorted나 sort라는 최적 정렬 함수를 활용해 날먹을(...) 시전할 수 있다. JAVA는 Collections.sort()를 사용하는 것이 유리하다.
주) 하지만 내가 시도했을 때는 Arrays.sort()보다 시간이 더 오래 걸렸다. 뭔 이유일지는... 잘 모르겠다?
sorted, sort, Collections.sort 모두 Timsort 방식을 사용하기 때문에 가능하다. 그리고 분할 정복 알고리즘을 이용하는 병합 정렬(Merge sort)도 가능하다.

원리 영상 : http://youtube.com/watch?si=oTDn3D4Tchzg6nwb&v=5Z9dn2WTg9o&feature=youtu.be (병합 정렬)
