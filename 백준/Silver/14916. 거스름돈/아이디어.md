# 아이디어
거스름돈 문제 유형은 사실상 배수 관계 그 이상이 아닌 거스름돈 유형이 아니라면 그리디 알고리즘이 최적해를 보장할 수가 없다.

## 문제 파악하기
2원짜리 동전과 5원짜리 동전을 무한정 많이 가지고 있을 때, 동전의 개수가 최소가 되도록 거스름돈 `n`을 거슬러줄 것이다. 첫째 줄에 10만 원 이하의 자연수 금액 `n`원이 주어지면, 거스름돈으로 거슬러줄 동전의 최소 개수를 출력하고 거슬러 줄 수 없는 경우는 -1로 출력하자.

## 방법 고안
사실상 여러 가지 방법이 존재할 수는 있기 때문에 실제로 여러 가지 방법을 제시해본다.

### 다이나믹 프로그래밍
앞쪽의 예외적인 케이스들을 제외한다면, 나머지는 사실 생각해보기 쉽다.
- 6원 정도부터 생각해보자.
	- 맨 마지막이 2원으로 거슬러주게 된다면 4원이 거슬러줄  수 있을 때 2원을 더 더해주면 되는데, 이러면 총 3개가 사용된다.
	- 맨 마지막이 5원으로 거슬러주게 된다면 1원이 거슬러줄 수 있을 때 5원을 더 더해주면 되는데, 이는 불가능하다.
- 즉, `n`원에 대하여 `n-2`원이 거슬러줄 수 있는 금액이거나 `n-5`원이 거슬러줄 수 있는 금액이면 그 때 사용하는 동전에 한 개를 더하면 되기 때문에 둘 다 가능하면 더 적은 것, 둘 다 불가능하면 불가능한 것이다.

이때 초기값으로는 0~5원 정도를 처리해주는 것이 편하다.

### 수학적 아이디어 + 그리디 알고리즘
결과적으로 5원과 2원은 굉장히 무관한 케이스이기 때문에 그리디가 성립할 수 있을까라는 생각을 할 수는 있다. 배수 경우로 주어진다면 더 큰 것으로 더 작은 것을 대체하는 것이 합리적이지만, 이는 그렇지 않기 때문이다.

하지만 이와 같은 경우에서는, 5원짜리 동전이 2원짜리 동전이 효율적이라는 점에서 어떤 상황에서도 더 많은 5원을 먼저 쓰는 것이 최적해로 이어지고, 실제로 5원을 많이 사용한 경우에서 2원으로 교환 가능한 경우를 따져보는 것이 최적해로 가까워진다.

그래서 5로 나누어떨어지면 계속 5를 빼서 5원을 한 개씩 더 세고, 아닌 경우는 2를 빼서 2원을 한 개씩 더 세는 방식으로 진행해서 그리디 알고리즘을 사용할 수 있게 된다.

## 코드화
### 다이나믹 프로그래밍
```JAVA
public class Main {
    public static int[] dp = new int[100001];
    public static void dp() {
        dp[0] = dp[1] = dp[3] = -1;
        dp[2] = dp[5] = 1;
        dp[4] = 2;
        for (int i = 6; i < 100001; i++) {
            int tempCase1 = -1, tempCase2 = -1;
            if (dp[i-2] != -1) tempCase1 = dp[i-2] + 1;
            if (dp[i-5] != -1) tempCase2 = dp[i-5] + 1;
            if (tempCase1 == -1 && tempCase2 == -1) dp[i] = -1;
            else if (tempCase1 == -1) dp[i] = tempCase2;
            else if (tempCase2 == -1) dp[i] = tempCase1;
            else dp[i] = Math.min(tempCase1, tempCase2);
        }
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        dp();
        System.out.println(dp[n]);
        br.close();
    }
}
```
`dp` 메소드 부분에서 아예 100000까지의 모든 경우를 계산해둔다.
- 1, 2, 3, 4, 5원의 경우는 미리 제시해둔다. 2원은 1개, 4원은 2개, 5원은 1개가 최소이며, 나머지는 불가능하다.
- 6원부터 실행하여 계산하는데, 우선 2원을 뺀 금액이 제시 가능한 금액이면 1을 더해서 저장한다.
- 그리고 5원을 뺀 금액이 제시 가능한 금액이어도 1을 더해서 저장한다.
- 각각의 경우를 저장한 `tempCase1`과 `tempCase2`에 대하여 불가능한 경우인 -1이 둘 다 나왔으면 불가능, 아닌 경우가 하나라도 있으면 그것을 따르고 둘 다 가능하다면 더 작은 것을 따른다.

구해진 배열에서 마지막으로 `main`에서 인덱스를 따라 값을 받아 출력하면 된다.

### 그리디 알고리즘
```JAVA
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine()), cnt = 0;
        while (true) {
            if (n == 1) {
                cnt = -1;
                break;
            }
            if (n <= 0) break;
            if (n % 5 == 0) {
                n -= 5;
                cnt++;
            } else {
                n -= 2;
                cnt++;
            }
        }
        System.out.println(cnt);
        br.close();
    }
}
```
n이 1일 때만 제외해주면 된다.
- 0 이하인 경우 (어차피 불가능한 경우는 1로 종료되게 되어 있음)는 break로 빠져나간다.
- 5로 나누어떨어지면 5를 빼고 `cnt`를 1 증가시킨다.
- 그렇지 않으면 2를 빼고 `cnt`를 1 증가시킨다.

이를 무한 반복한다. 그러면 0으로 빠져나오거나 2원으로도 커버가 되지 않아 1원이 남아 -1이 출력될 것이다. 0으로 나오면 `cnt`를 출력해주면 된다.

## 정리
![](https://velog.velcdn.com/images/aoi-aoba/post/bbfd1825-4fde-4d78-b7b1-3e1ac3cb2c67/image.png)

첫 번째 줄이 그리디 알고리즘이고, 세 번째 줄이 다이나믹 프로그래밍 방식이다.

> 그리디 알고리즘의 시간 복잡도   
> 주요 반복문이 while 문인데, n이 2 또는 5만큼 줄어들면서 체크하게 되므로 n이 2만 줄어드는 경우가 가장 적은 경우이고 반복 횟수는 최대 약 $n/2$번이나 결과적으로는 $O(n)$을 따르게 된다. 하지만 그리디 성질로 인해서 실제로 반복 횟수는 그것보다 적다.

> 동적 계획법 (다이나믹 프로그래밍)의 시간 복잡도   
> 주요 연산 횟수는 dp 메소드에서 진행되는 for 루프이므로 각 연산은 상수 시간 연산이기 때문에 $O(n)$을 따른다.

사실상 n의 범위가 커진다면 동적 계획법이 더 효율적이지만 그렇게 큰 범위가 아닌지라 그리디 알고리즘이 꽤 효과를 보인다.
