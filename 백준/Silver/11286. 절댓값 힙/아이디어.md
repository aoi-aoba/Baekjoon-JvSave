# 아이디어
말 그대로 절댓값 힙을 구현하는 문제이다. 힙 구조를 잘 활용하자.

## 문제 파악하기
절댓값 힙이 다음과 같은 연산을 지원한다.
- 배열에 정수 $x$ ($x \not= 0$)을 넣는다.
- 배열에서 절댓값이 가장 작은 값을 출력하고 그 값을 배열에서 제거한다.
- 절댓값이 가장 작은 값이 여러 개일 때에는 가장 작은 수를 출력하고, 그 값을 배열에서 제거한다.

프로그램이 처음 시작할 때는 비어있는 배열에서 시작한다. 절댓값 힙을 구현하자.

---

입력은 다음과 같이 주어진다:
- 첫째 줄에 연산 개수 $N$이 10만 이하의 자연수로 주어진다.
- 다음 $N$개 줄에는 연산 정보를 나타내는 정수  $x$가 주어진다.
  - 만약 $x$가 0이 아니라면 배열에 $x$를 추가하는 연산이다.
  - 만약 $x$가 0이라면 배열에서 절댓값이 가장 작은 값을 출력하고 그 값을 배열에서 제거하는 연산이다.
  - 입력 정수 $x$는 절댓값이 $2^{31}$ 보다 작은 정수이다.
  
출력은 입력에서 0이 주어진 횟수만큼 답을 출력하며, 만약 배열이 비어 있을 때 가장 절댓값이 작은 값을 출력하라고 한다면 0을 출력한다.

## 방법 고안
두 가지 방법을 차례대로 소개한다. 모두 `PriorityQueue`를 사용하는 방식이다.

### 음수와 양수를 따로 구분하는 방식
`PriorityQueue`를 활용하여 정렬한다는 것을 기본 베이스로 깔고 진행하자. 그렇게 한다면, 우리는 절댓값 비교만 확실히 해주면 된다.

만약, `-1 2 -3 4 -5 6`이 주어져  있다고 하자. 그러면 출력해야 하는 것은 절댓값이 가장 작은 값이다. 이때, 우리는 이걸 음수와 양수에 대해 따로 정리한다.

음수에는 절댓값이 클 수록 작아지므로, 최소 힙으로 정렬한다. 그리고, 양수는 절댓값이 클 수록 큰 값이므로, 최대 힙으로 정렬한다. 그렇게 된다면, (물론 내부 구조는 다르지만 정렬 순서 기준으로) 양수에는 `2 4 6` 형태로, 음수에는 `-1 -3 -5` 형태로 정렬한 것처럼 우선순위를 가진다.

여기에서 `peek()` 혹은 `poll()`을 사용하게 된다면 양수 쪽에는 `2`가 나올 것이고, 음수 쪽에는 `-1`이 나올 것이다. 이 둘에 대해 절댓값을 비교하여 더 작은 쪽만 원소를 빼내면 된다.

즉, 분기가 두 번 나뉘게 되는 것인데,
- 맨 처음에는 수가 0인지 음수인지 양수인지 구분해야 한다. 음수거나 양수이면 해당 `PriorityQueue`에 삽입한다. 아니면 출력을 진행해야 한다.
- 수가 0이라면, 음수와 양수가 각각 들어가 있는 `PriorityQueue`를 살펴본다. 만약, 어느 한 쪽이 비어있다면 안 빈 곳의 원소를 빼 오면 되고, 양쪽 모두 비어 있다면 0을 출력하고, 둘 다 존재한다면 `peek()`를 통해 원소를 가져와 값을 비교하여 더 작은 값을 출력한다.

이런 방식으로 운영할 수가 있다.

### PriorityQueue 규칙을 별개로 지정하는 방식
`PriorityQueue` 객체는 다음과 같이 생성한다.
```
PriorityQueue<Integer> pq = new PriorityQueue<>();
```

이때, 우리는 기본 정렬규칙인 최소 힙 형태(오름차순)로 내부가 정렬되는 것을 확인할 수 있다. 하지만, 이 규칙을 변경할 수도 있다.
```
PriorityQueue<Integer> pq = new PriorityQueue<>(
	// lambda expressions or Collections Method
)
```

`new PriorityQueue<>()`의 소괄호 부분 안에 람다식을 집어넣거나, `Collections.reverseOrder()`(최대 힙, 내림차순) 같은 메소드를 집어넣을 수 있다. 그래서, 아예 우리가 원하는 대로 별개의 규칙을 생성할 수 있다. 정렬 규칙 자체를 다음과 같이 설정해보자.

- 두 개의 원소에 대해 절댓값이 다르다면, 절댓값이 작은 순서대로
- 두 개의 원소의 절댓값이 같다면, 값이 작은 순서대로

비교를 위해서는 `return`을 활용하여 0을 기준으로 하여 작은 값이나 큰 값을 `return`하는 것으로 규칙을 설정할 수 있다. `new Comparator` 규칙을 선언하는 것과 비슷한 원리이다.

---

이 방법을 각각 활용하여 코드를 구현해보자.

## 코드화
### 방법 1: 두 개의 PriorityQueue를 사용하여 음수와 양수를 구분
```java
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int N = Integer.parseInt(br.readLine());
        PriorityQueue<Integer> heapNor = new PriorityQueue<>();
        PriorityQueue<Integer> heapRev = new PriorityQueue<>(Collections.reverseOrder());

        for (int i = 0; i < N; i++) {
            int temp = Integer.parseInt(br.readLine());
            if (temp < 0) heapRev.add(temp);
            else if (temp > 0) heapNor.add(temp);
            else {
                if (heapNor.isEmpty() && heapRev.isEmpty()) bw.write("0\n");
                else if (heapNor.isEmpty()) {
                    bw.write(String.valueOf(heapRev.poll()) + "\n");
                } else if (heapRev.isEmpty()) {
                    bw.write(String.valueOf(heapNor.poll()) + "\n");
                } else {
                    if (heapNor.peek() >= heapRev.peek() * (-1))
                        bw.write(String.valueOf(heapRev.poll()) + "\n");
                    else bw.write(String.valueOf(heapNor.poll()) + "\n");
                }
            }
        }

        bw.flush();
    }
}
```

코드 자체에 모두 적혀 있고 위에서 설명한 그대로이다.
- `heapNor`은 일반 정렬 규칙(최소 힙)을 따르기 때문에 `poll()` 내지는 `peek()`를 선언하면 가장 작은 값이 나오게 된다. 양수를 집어넣는다.
- `heapRev`는 정렬 규칙의 역순(`Collections.reverseOrder()`)을 따르기 때문에, 가장 큰 값이 나오게 된다. 음수를 집어넣으면 절댓값이 가장 작은 음수가 가장 큰 값을 가져 나올 수 있다.

그래서 `for` 문을 돌면서 값을 받고 지정된 `heapNor` 혹은 `heapRev`에 값을 집어넣으며, 값이 0인 경우에는 `isEmpty()` 메소드 호출 결과에 따라서 모두 원소가 없으면 0을, 어느 한쪽만 있으면 그 값을, 둘 다 있다면 음수 쪽에 대해 -1을 곱하여 절댓값을 비교해 원하는 값을 출력한다.

- `heapNor.peek()`가 `heapRev.peek()`에 -1을 곱한 값보다 크다면 절댓값이 더 작은 걸 출력해야 하므로 `heapRev.poll()`
- 만약 두 값이 같게 된다면, 값이 더 작은 것을 출력해야 하므로 음수인 `heapRev.poll()`
-  그렇지 않은 경우는 `heapNor.poll()`

### 방법 2: PriorityQueue 규칙 설정
```java
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int N = Integer.parseInt(br.readLine());
        PriorityQueue<Integer> pq = new PriorityQueue<>((o1, o2) -> {
           if (Math.abs(o1) != Math.abs(o2))
               return Math.abs(o1) - Math.abs(o2);
           return o1 - o2;
        });

        while (N-- > 0) {
            int temp = Integer.parseInt(br.readLine());
            if (temp == 0)
                bw.write((pq.isEmpty() ? 0 : pq.poll()) + "\n");
            else pq.offer(temp);
        }

        bw.flush();
    }
}
```

람다식을 활용하여, 두 수가 절댓값이 다르면 `o1`의 절댓값에서 `o2`의 절댓값을 뺀 값을 `return`한다. `Integer.compare()`의 메소드와 다를 게 없다. 절댓값이 같으면 그냥 두 수를 직접 직관적으로 빼면 된다. 그 값을 `return`한다. 커스텀 Comparator 규칙을 사용하는 것이다.

그러면 정렬은 알아서 진행이 될테니, 비어 있을 때만 0을 출력하고 아니라면 계속 값을 집어넣다가 비어있지 않을 때 출력하라고 하면 그 값을 하나 꺼내서 출력하면 된다.

## 정리
`PriorityQueue`를 사용하는 전형적인 문제. 다른 방법으로 구현도 충분히 가능하겠지만 굳이 그렇게까지 할 필요가 있을까 싶다?
