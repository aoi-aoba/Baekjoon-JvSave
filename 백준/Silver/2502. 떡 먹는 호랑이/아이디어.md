# 아이디어
~~호랑이한테는 역시 떡을 줘버릇하면 안 된다.~~   
직관적으로 어떤 규칙이 존재하는데, 그 규칙 속에서도 또 다른 규칙이 존재한다는 것을 캐치하는 것이 중요하다.

## 문제 파악하기
떡 장사를 하는 할머니가 하루에 한 번 산을 넘어갈 때 호랑이에게 떡을 주어야 넘어갈 수 있는데, 욕심 많은 호랑이가 어제 받은 떡의 개수와 그저께 받은 떡의 개수를 더한 만큼의 떡을 받아야 할머니를 무사히 보내 준다고 한다.

가령, 첫째 날에 1개, 둘째 날에 2개를 주었다면 셋째 날에는 3개, 넷째 날에는 5개, 다섯째 날에는 8개, 여섯째 날에는 13개를 주어야 무사히 넘어갈 수 있다.

오늘 할머니는 산을 무사히 넘어오셨다. 오늘이 며칠 째이고, 떡을 몇 개 주셨는지 알아내었을 때, $D$일째 날에 $K$개의 떡을 주었다고 하였다면 처음 만난 날에 준 떡의 개수 $A$와 둘째 날에 준 떡의 개수 $B$를 구해보자.

입력은 다음과 같이 주어진다.
- 첫째 줄에 할머니가 넘어온 날 $D$, 그리고 호랑이에게 준 떡의 개수 $K$가 공백으로 구분되어 주어진다.
- $D$는 3 이상 30 이하의 자연수이며, $K$는 10 이상 10만 이하의 자연수이다.
- 이 문제에서 항상 $A$는 1 이상이고, $B$는 $A$ 이상이다.

출력은 다음과 같이 하면 된다.
- 첫째 줄에 첫째 날에 준 떡의 개수 $A$를 출력한다.
- 둘째 줄에 둘째 날에 준 떡의 개수 $B$를 출력한다.
- 이 문제에서 주어진 $D, K$의 값에 대해 항상 정수 $A, B$가 자명하게 존재한다. 
- 어떤 경우에는 답이 되는 $A, B$가 하나 이상일 수도 있는데, 이 경우 하나만 구해서 출력하면 된다.

## 방법 고안
직접 좀 써 보는 것이 중요한 문제였긴 하다.

### D번째 날에 할머니는 몇 개의 떡을 주어야 할까?
우리가 찾아야 하는 것을 아예 미지수로 두어 생각해보자. 첫째 날에 준 떡의 개수 $x$와 둘째 날에 준 떡의 개수 $y$에 대하여 $D$번째 날까지 진행하면, 다음과 같이 진행된다.

- 1일 : $x$
- 2일 : $y$
- 3일 : $x + y$
- 4일 : $x + 2y$
- 5일 : $2x + 3y$
- 6일  : $3x + 5y$

잘 보면, 다음과 같이 정리할 수 있다.
- $D$일차에 대하여 $ax + by$의 꼴로 정리한다고 하면
- $a$ ($x$의 계수) : $1, 0, 1, 1, 2, 3, \cdots$
- $b$ ($y$의 계수) : $0, 1, 1, 2, 3, 5, \cdots$

즉, 문제 자체의 구조도 피보나치 수열과 비슷한 구조로 올라가는데, 값의 내부에서도 계수가 **피보나치 수열**&ZeroWidthSpace;을 따르고 있음을 알 수 있다.

### 방정식을 푸는 것은 어떻게 하면 될까?
그러면 아예 계수를 다 정해 놓고, 방정식을 구하는 것은 가능해졌다. 예제 입력 2에서 7일차에 218개라는 단서를 활용하여 방정식을 세워보면 아까 6일차가 $3x + 5y$였으므로 7일차는 $5x + 8y$이다. 즉, $5x + 8y = 218$이다.

미지수가 두 개인 일차방정식이므로 `for` 루프 두 개로서 $x, y$를 추론할 수도 있다. 하지만 이러면 시간 복잡도가 $O(n^2)$으로 팍 튀어버린다. 그렇기 때문에 사용할 수 있는 방법을 살짝 바꾸면 된다.

어차피 해가 존재하는 방정식이 주어짐을 문제에서 자명하게 주었기 때문에, 둘 중 하나의 수를 잡아서 먼저 채우고, 나머지 수를 확인하면 된다.

이때, $y$에 대해서 확인하는 것이 좋다. 시작값을 $x = 0$이라고 해보자. 그러면 $y = 218 \div 8 = 27.\cdots$이므로 $y = 27$부터 내려오면서 계속 확인해보는 것이다.

- $y = 27$일 때 $5x + 216 = 218$이므로 $x$는 자연수가 아니다.
- $y = 26$일 때 $5x + 208 = 218$이므로 $x = 2$일 때 성립한다.

즉 가능한 답 중 하나인  $(x, y) = (2, 26)$의 해를 구할 수 있게 된다.

> 물론 실제 예제 출력 2로 제시된 것은 $(x, y) = (10, 21)$이긴 한데, 이는 문제에서도 주어진 내용이다. '어떤 경우에는 답이 되는 $A, B$가 하나 이상일 수도 있는데, 이 경우 하나만 구해서 출력하면 된다'.

---

이 점에 착안하여 코드를 짜면 되는 것이다.

## 코드화
### setArrDP 메소드
```java
public class Main {
    public static int[] arrX = new int[31], arrY = new int[31];
    public static void setArrDp() {
        arrX[1] = arrY[2] = 1;
        arrX[2] = arrY[1] = 0;
        for (int i = 3; i < 31; i++) {
            arrX[i] = arrX[i - 2] + arrX[i - 1];
            arrY[i] = arrY[i - 2] + arrY[i - 1];
        }
    }
```
bottom-up 방식으로 DP 테이블을 구성하여 아예 30일에 대한 모든 `x`와 `y`의 계수를 `arrX`와 `arrY`에 저장해두었다. 피보나치 수열이므로 초기값 두 개만 지정해주면, 3일차부터 30일차까지 구하는 것은 그저 덧셈만 해주면 된다.

### main 메소드
```java
	...
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        setArrDp();
        StringTokenizer st = new StringTokenizer(br.readLine());
        int d = Integer.parseInt(st.nextToken()), k = Integer.parseInt(st.nextToken());
        int a = arrX[d], b = arrY[d];

        int A = 0, B;
        for (B = k / b; B >= 0; B--) {
            if ((k - (b * B)) % a == 0) {
                A = (k - b * B) / a;
                if (A <= B && A >= 1) break;
            }
        }

        bw.write(String.valueOf(A) + "\n");
        bw.write(String.valueOf(B) + "\n");
        bw.flush();
    }
}
```

`setArrDp()` 메소드를 호출하여 기본 세팅을 한 다음, 값을 받아서 각 계수와 `d`일, `k`개의 떡을 모두 값을 저장한다. 그리고 `A`와 `B`를 계산하는데, 이때, `aA + bB = k`라는 식인 상황이다. (문제의 입/출력 조건에서 `x`, `y`가 아니고 `A`, `B`를 사용해서 이렇게 진행했다.) `B`의 초기조건은 `k / b`, 즉 `A = 0`인 상황이고 이때부터 `B`를 줄여나가면서 체크한다.

## 정리
미지수가 두 개인 일차방정식에 대하여 $O(n)$으로 풀이하는 것이 더 유리한 시간 복잡도를 얻을 수 있다. $O(n^2)$이어도 시간 초과가 팍 튀진 않을 것 같긴 한데, 굳이 그렇게 할 이유도 없었다.
