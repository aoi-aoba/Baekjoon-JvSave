# 아이디어
다이나믹 프로그래밍의 전형적인 Unbounded Knapsack (무한 배낭 문제) 형태에 해당하는 문제

## 문제 파악하기
$N$종류의 컵이 있는데, 그 컵은 쉽게 정리할 수 있게 종류에 무관하게 컵 입구에 빈틈이 없게 포개어진다는 장점이 있다. 문제의 편의 상 몸통은 제외하고 입구만 생각하자.

![](https://velog.velcdn.com/images/aoi-aoba/post/7231bbe2-e0ff-44d4-92c8-64ecdefbda9d/image.png)

컵의 입구 부분 높이 총합이 $H$가 되게 하는 경우의 수를 구해보려고 한다. 모든 컵은 무한히 많이 존재하고, 각 종류의 컵은 높이가 정해진 단위 높이 1의 양의 정수배에 해당한다. 즉, 자연수이다. 컵을 포갤 때는 입구가 위에 오게 포갠다. 

![](https://velog.velcdn.com/images/aoi-aoba/post/912ff3ca-630c-47bf-81c7-ebef8f3cc251/image.png)

![](https://velog.velcdn.com/images/aoi-aoba/post/7b5f0ea3-2fa7-491a-b1c3-f42a3bfa964e/image.png)

입력의 조건은 다음과 같다.
- 첫째 줄에 컵의 종류 개수인 100 이하의 자연수 $N$과 목표하는 높이인 10만 이하의 자연수 $H$가 공백을 사이에 두고 주어진다.
- 둘째 줄에는 $N$종류의 컵의 높이가 각각 100을 넘지 않는 자연수로 공백을 사이에 두고 주어진다.

출력의 조건은 다음과 같다.
- 첫 번째 줄에 높이가 정확히 $H$가 되도록 컵을 포개는 경우의 수를 $10^9+7$로 나눈 나머지를 출력한다.

## 방법 고안
사실상 다이나믹 프로그래밍이라는 감을 잡을 수 있는 것은 쉽게 감을 잡을 수 있었을 것이다. 여기에서 감안해야 하는 몇 가지 생각은 다음과 같았다.

### 컵을 쌓는 순서? 조합? 순열?
이 문제에서는 컵을 어떻게 쌓았는지에 대한 순서가 영향을 받는 경우이다. 예를 들어, 컵이 높이 1과 2가 있다면 높이 3을 만들 때 `(1, 2)`와 `(2, 1)`은 서로 다른 방법이다. 중복순열 혹은 순서 있는 조합의 문제라는 것이다.

### 총 높이 H를 만드는 경우의 수, 그리고 다이나믹 프로그래밍
다이나믹 프로그래밍의 테이블을 정의하고 싶은데, 여기에서 정의할 것은 아무래도 '총 높이 H를 만드는 경우의 수'이다. 초기화할 내용은 한 가지 정도겠다. `dp[0] = 1` 즉 0인 높이는 아무것도 안 쌓는 것의 한 가지. 나머지는 가능한 컵에 대해 특정 로직으로 값을 더해주면서 바꿔야 한다.

### 반복문의 설계
무한히 쓸 수 있는 컵이라고 하였고, 순서를 고려해야 하기 때문에, 반복문의 순서를 잘 고려해야 한다. 높이를 고려하는 반복문이 필요할 것이고, 컵 종류에 대한 것을 고려하는 반복문이 필요할 것이다. 즉, 높이 1부터 H까지 차례대로 만들어 가면서, 각 높이에 대해 가능한 모든 컵 종류를 써서 만들어보는 시도를 하게 반복문 구조를 잡아야 하는 것이다. 이중 for 문이 적절할 것이다.

### 가능한 컵의 높이
가능한 컵의 높이가 1이나 2 같은 정도로 한정되어 있다면, 그냥 `dp[i] = dp[i-1] + dp[i-2] + ...`과 같은 형태가 가능하지만, 지금은 그런 상황의 문제가 아니다. 그러면 여기에서 사용할 방법은, `dp[i] += dp[i-a]` (단, `a`는 컵의 높이이며 `i-a`의 값은 0 이상이어야 함)의 로직을 사용해서 배열을 계속 바꿔주면 되겠다.

---
이 아이디어를 기반으로 문제를 풀어보면 금방 해결 가능하다. 다이나믹 프로그래밍의 바텀업 방식을 활용하여 풀어보자.

## 코드화
```java
public class Main {
    public static int[] cups, dp;
    public static int dp(int height) {
        dp[0] = 1; // 높이가 0인 경우는 컵을 안 쓰는 것 1가지
        for (int i = 1; i < dp.length; i++) // 목표 높이까지 높여가면서
            for (int temp : cups) // 주어진 컵들에 대해서
                if (i - temp >= 0) {
                    dp[i] += dp[i - temp];
                    dp[i] %= 1000000007;
                }
                // (목표 높이 - 특정 컵) 높이를 만드는 경우의 수를 목표 높이에 합치기
        return dp[dp.length-1];
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int cupType = Integer.parseInt(st.nextToken()), targetHeight = Integer.parseInt(st.nextToken());
        cups = new int[cupType];
        dp = new int[targetHeight+1];
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < cupType; i++) cups[i] = Integer.parseInt(st.nextToken());
        System.out.println(dp(targetHeight));
    }
}
```
### main
입력을 받아와서 컵 입구 부분 높이를 `cups` 배열에 모두 저장하고, `targetHeight`보다 1 큰 값으로 해당 높이까지 인덱스로서 표현할 수 있게 `dp` 배열을 만들어준다. 그런 다음, `dp()` 메소드로 넘겨서 리턴 값을 출력하는 게 전부이다.

### dp 메소드
높이가 0인 경우는 컵을 안 쓰는 것의 한 가지이다. 그러니까 초기화는 `dp[0]` 인덱스의 값 `1` 정도이다. 그리고, 1부터는 목표 높이까지 높여가면서 진행하면 되는데, 바깥의 for 문에서 목표 높이로 올라가고, 안쪽의 for 문에서는 각각의 컵에 대해서 현재 돌고 있는 `i`의 높이에서 그 값을 빼서 0 이상이면 이미 이전에 찾아둔 경우의 수가 나올 것이기 때문에 그 값을 더해주면 된다.

가령, `dp[4]`의 높이를 확인해보려고 할 때, 컵이 `1`의 높이를 가진다면 높이가 `3`인 경우에 대해서 해당 컵을 하나씩 더 놔 준다고 생각하면 되므로 `dp[4]`에다가 `dp[3]`의 경우의 수를 더해주는 것이다. 다른 컵이 높이 `4`가 있다고 한다면, 해당 컵을 놓기만 하면 되기 때문에 `dp[0]`을 더해주면 되는 것이고, `dp[0]`은 맨 처음에 '아무것도 놓지 않는다'의 경우의 수 한 가지만 존재하므로 같은 원리로 값을 더해나갈 수 있는 것이다.

오버플로우와 출력 형식을 맞추기 위해 if문을 돌 때 값을 더하면서 바로 mod 연산까지 진행해준다. 마지막에는 원하는 값을 리턴해주면 된다. main에서는 그 리턴 값을 그대로 출력할 것이므로.

## 정리
동적 계획법(다이나믹 프로그래밍)은 항상 어떤 규칙성을 발견하여 그걸 구현하는 것이 중요하다. 시간 복잡도는 외부 반복이 높이 $H$까지이고 내부 반복은 주어지는 컵의 종류 수 $N$ 만큼이므로, 입력 제한 하에서 전체 시간 복잡도는 $O(H \times N)$이며 $10^7$ 정도이므로 넉넉히 1초 안에 충분히 통과할 수 있는 수준이다. 공간 복잡도 역시 `dp[]` 배열과 `cups[]` 배열에 $O(H+N)$ 정도의 메모리만 사용한다.
