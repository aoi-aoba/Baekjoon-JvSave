# 아이디어
맵을 잘 구현해서, 최단시간에 이동할 수 있도록 하면 된다. 생각보다 어려운 문제까지는 아니다?

## 문제 파악하기
![](https://velog.velcdn.com/images/aoi-aoba/post/5a874d32-640c-4ab0-9271-e95a4a61e8d4/image.png)

뱀과 사다리 게임이 있다. 정육면체 주사위를 사용하며 각 면에는 1에서 6까지의 수가 하나씩 적혀 있다. 게임은 크기가 $10 \times 10$ 크기의 정사각형이고, 100개의 칸이 있는 보드판에서 진행한다. 보드판에는 1~100의 수가 하나씩 순서대로 적혀 있다.

플레이어는 주사위를 굴려 나온 수만큼 이동한다. 예를 들어 플레이어가 $i$번 칸에 있고 주사위를 굴려 4가 나왔다면 $i+4$번 칸으로 이동한다. 만약 주사위가 100번 칸을 넘어간다면 이동할 수 없다. 도착한 칸이 사다리면, 사다리를 타고 올라간다. 뱀이 있는 칸이라면 뱀을 따라 내려간다. 즉, 사다리를 이용해 이동한 칸의 번호는 원래 있던 칸의 번호보다 크고, 뱀을 이용해 이동한 칸의 번호는 원래 있던 칸의 번호보다 작아진다.

게임의 목표는 1번 칸에서 시작해서 100번 칸에 도착하는 것이다. 이때, 이 게임에서 **주사위를 조작해 내가 원하는 수가 나오게 만들 수 있다면, 최소 몇 번 만에 도착점에 도착할 수 있을까?** 게임판의 상태가 주어지면, 100번 칸에 도착하기 위해 주사위를 굴려야 하는 횟수의 최솟값을 구하자.

---

입력은 다음과 같이 주어진다:
- 첫 줄에는 게임판의 사다리 개수 $N$과 뱀의 수 $M$이 15 이하의 자연수로 주어진다.
- 둘째 줄부터 $N$개의 줄에는 사다리 정보 $x$ $y$가 주어진다. $x<y$를 만족하며, $x$번 칸에 도착하면 $y$번 칸으로 올라간다는 의미이다.
- 그 다음 $M$개 줄에는 뱀 정보 $u$ $v$가 주어진다. $u < v$를 만족하며, $u$번 칸에 도착하면 $v$번 칸으로 내려간다는 의미이다.
- 1번과 100번은 뱀이나 사다리의 시작 또는 끝이 되지 않는다. 모든 칸은 최대 하나의 사다리 또는 뱀을 가지고 있으며 동시에 두 가지를 가질 수는 없다. 항상 100번 칸에 도착 가능한 입력만 주어짐이 자명하다.

출력은 100번 칸에 도착하기 위해 굴려야 할 최소 주사위 횟수를 출력하자.

## 방법 고안
최단 시간 내에 가야 하기 때문에 BFS를 이용하되, dx-dy로 움직이는 것을 일차원 선 상에서 이동한다는 것으로 보는 것이 좋겠다.

### 1차원에서의 이동에 대해 : dx-dy를 변형하자
주사위를 굴려서 이동하기 때문에, dx 하나만 사용하면 된다. 주사위 눈은 1~6으로 나타나므로,
```java
public static int[] dx = {1, 2, 3, 4, 5, 6};
...
for (int i = 0; i < 6; i++) {
	int nx = x + dx[i];
}
```
와 같이 움직이면 되겠다.

### 뱀과 사다리에 대하여
일반적으로 생각하기에, 뱀은 아래로 내려가고 사다리는 위로 올라가니까 사다리는 무조건적으로 타야 하고 뱀은 안 타야 한다고 생각하기 쉽다. 어차피 사다리는 BFS로 탐색하면서 타거나 안 타거나 고려되겠지만, 뱀을 처음에는 나도 배제해볼까 생각했었다. 하지만, 뱀을 타는 것이 최단 거리일 가능성을 배제할 수는 없다.

가령, 사다리는 20 -> 70으로 가는 사다리와  50 -> 98로 가는 사다리가 있다고 하고, 뱀이 72 -> 48로 가는 뱀이 있다고 하자. 그러면, 뱀을 무시하게 된다면 다음과 같이 가야 한다.
> 1 > 7 > 13 > 19 > 20 - 70 > 76 > 82 > 88 > 94 > 100   
> 또는   
> 1 > 7 > 13 > 19 > 25 > 31 > 37 > 43 > 49 > 50 - 98 > 100

위의 두 경우의 수에 대하여 위쪽 줄에서는 9번, 아래쪽 줄에서는 10번 주사위를 던져야 하지만 뱀을 감안하게 된다면 더 짧은 거리가 나올 수 있다.
> 1 > 7 > 13 > 19 > 20 - 70 > 72 - 48 > 50 - 98 > 100

이 경우에 대해서는 7번 던져서 도달할 수 있기 때문에 훨씬 짧아진다. 그렇기 때문에, 뱀과 사다리를 타고 갔을 경우에 대해서도 그냥 모두 알아보고 최단 거리가 도달하면 사전에 종료해버리는 규칙만 지정해주면 충분하다.


### 게임판을 어떻게 구성해야 하는가
가장 쉬운 방법은, 게임판을 저장하는 1차원 배열과 이미 간 곳인지 아닌지 확인하는 1차원 배열을 별도로 저장하는 것이다. 그렇게 한다면, 게임판을 저장하는 1차원 배열에는 `int` 형 배열을 활용하여 1~100의 인덱스에 대하여 0이라는 값이면 그저 그 칸에 있으면 되고, 뱀이나 사다리는 그냥 그 인덱스에 이동할 칸의 값을 지정해서 그 칸으로까지 이동하는 걸 1회의 주사위를 던진 것으로 감안하면 되겠다. 방문 여부를 체크하는 배열을 쓴다고 해서 메모리 차이가 그렇게 크지도 않을 것이고, 동시에 이 배열을 활용함으로서 무한 루프에 빠지는 걸 막을 수 있다. 뱀을 타면 불리해지는 경우, 아래로 내려가서 다시  또 올라와서 그 뱀을 또 타게 되면 그건 계속 무한 루프에 빠지기 때문에 이미 방문한 곳은 다시 방문하지 않게 하는 것이 중요하다.

---

## 코드화
### BFS를 활용하기 위한 메소드 구조
```java
public class Main {
    public static int[] dx = {1, 2, 3, 4, 5, 6};
    public static int[] board = new int[101];
    public static boolean[] visited = new boolean[101];
    public static Queue<int[]> Q = new ArrayDeque<>();

    public static void bfs() {
        while (!Q.isEmpty() && !visited[100]) {
            int[] cur = Q.poll();
            int x = cur[0], d = cur[1];

            for (int i = 0; i < 6; i++) {
                int nx = x + dx[i];
                if (nx >= 0 && nx < 101 && !visited[nx]) {
                    if (board[nx] == 0) {
                        Q.offer(new int[]{nx, d + 1});
                        visited[nx] = true;
                        board[nx] = d + 1;
                    } else {
                        Q.offer(new int[]{board[nx], d + 1});
                        visited[nx] = true;
                        board[board[nx]] = d + 1;
                    }
                }
            }
        }
    }
```

`int[]` 1차원 배열 `board`는 게임판을 저장한다. 주사위를 돌린 것을 구현하기 위해 1차원의 dx 배열을 지정하고, 방문한 곳을 체크하기 위해 `boolean[]` 1차원 배열 `visited`를 두었다. Queue `Q` 역시 전역 선언했다.

`bfs` 알고리즘은 다음과 같이 구현한다.
- `bfs()`의 시작 지점은 1이 자명하기 때문에 굳이 parameter까지 두지는 않았다.  반복 조건은 일반적인 `bfs`처럼 Queue가 비어 있지 않으면서 100번 칸에 도착하지 않는, 즉 `visited[100]`이 `true`가 아닐 때 반복한다.
- Queue에서 좌표를 하나씩 꺼내어 순회한다. 이 지점을 `x`로 둔다. 위치에 도달할 때까지 걸리는 주사위 횟수는 `d`라는 변수에 지정한다. 그리고 for 문을 이용해 이동한 `nx`의 값을 구한다.
- 해당 값이 '범위 내에 존재'하는지, 그리고 방문한 적 없는 곳인지 체크한 다음, 그 다음에는 보드판을 체크해야 한다.
- 보드판을 체크했을 때 0이라는 값이라면, Queue에 주사위 횟수를 1 추가하면서 다음에 시작할 곳으로 두고 `true`로 바꾼다. 그런 뒤, `board[nx]`에는 `d+1`을 지정한다.
- 보드판을 체크했을 때 0이 아니라면 뱀 혹은 사다리가 있다는 것이므로, 다음 시작할 지점은 `board[nx]`로 두어야 한다. (즉, 뱀이나 사다리가 가리키는 곳으로 지정한다) 그리고, `board[board[nx]]` 즉 뱀이나 사다리가 가리키는 그 곳에 대하여 `d+1`을 지정하는 것이다.

### main 메소드
```java
	...
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int ladder = Integer.parseInt(st.nextToken()), snake = Integer.parseInt(st.nextToken());

        for (int i = 0; i < ladder; i++) {
            st = new StringTokenizer(br.readLine());
            int start = Integer.parseInt(st.nextToken()), end = Integer.parseInt(st.nextToken());
            board[start] = end;
        }

        for (int i = 0; i < snake; i++) {
            st = new StringTokenizer(br.readLine());
            int start = Integer.parseInt(st.nextToken()), end = Integer.parseInt(st.nextToken());
            board[start] = end;
        }

        visited[1] = true;
        Q.offer(new int[] {1, 0});
        bfs();
        System.out.println(board[100]);
    }
}
```

사실상 문제에서 사다리와 뱀의 수를 주는 것에 대해 어떻게 그 수를 사용해야 할 지 별로 생각하지 못했다. 그냥, 저 두 개의 `for` 문은 사실상

```java
for (int i = 0; i < ladder + snake; i++) {
	st = new StringTokenizer(br.readLine());
   	int start = Integer.parseInt(st.nextToken()), end = Integer.parseInt(st.nextToken());
    board[start] = end;
}
```
로 찹쳐도 크게 문제가 되진 않을 것이다. 아무튼, 그렇게 뱀과 사다리의 정보를 받아서 게임판 `board[]`에 저장해두고, 처음 시작하는 `visited[1]`은 `true`로 두고 Queue에 1번 칸은 0번의 주사위를 던져 도착하는 곳이라고 넣어주고 `bfs()`를 호출해 시작하고, 맨 마지막에는 종료 시점을 기점으로 하여 `board[100]`에 저장된, 그곳에 도착하기 위해 사용한 주사위 횟수를 출력해주면 된다.

## 정리
BFS-DFS 문제들은 1차원에서 3차원까지 다양한 공간이 주어지고, 주어지는 정보를 처리하기 위해 사용해야 하는 배열의 개수나 목적의 차이도 분명히 존재한다. 또한, dx만, dx-dy로,  dx-dy-dz로, 또는 각각의 이동 방식에 따라 구현해야 할 방식이 다 다르다.
