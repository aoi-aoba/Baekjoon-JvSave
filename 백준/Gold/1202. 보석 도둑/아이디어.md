# 아이디어
정렬이 필요할 것 같은데 정렬을 쓰기에는 뭔가 자료의 양이 많다. 그러면 쓸 수 있는 것은?

## 문제 파악하기
보석점에 보석이 $N$개 있다. 각 보석은 무게 $M_i$와 가격 $V_i$를 가지고 있다. 가지고 있는 가방 $K$개에는 각각 최대 무게  $C_i$까지 담을 수 있으며 가방에는 최대 한 개의 보석만 넣을 수 있을 때, 이 도둑이 훔칠 수 있는 보석의 최대 가격을 구하자.

---

입력은 다음과 같이 주어진다.
- 첫째 줄에 $N$과 $K$가 30만 이하의 자연수로 주어진다.
- $N$개 줄에 걸쳐 각 보석의 정보 $M_i$와 $V_i$가 100만 이하의 자연수로 주어진다.
- 그 다음 $K$개 줄에 걸쳐 각 가방에 담을 수 있는 최대 무게 $C_i$가 1억 이하의 자연수로 주어진다.

출력으로 도둑이 훔칠 수 있는 보석 가격의 합의 최댓값을 출력하자.

## 방법 고안
보석이랑 가방에 대하여 어떻게 하면 효과적으로 정렬하여 높은 가격의 보석을 담을 수 있을까?

### 예시를 통해 직접 생각해보기
예제 1에서
```
2 1
5 10
100 100
11
```
이 경우는 보석이 2개밖에 없다. 그래서 사실상 두 보석 중에 담을 수 있는 가방이 버틸 무게 11에 대해 무게 5인 보석밖에 없으므로 10이다.

예제 2에서
```
3 2
1 65
5 23
2 99
10
2
```
이 경우를 생각해보자. 보석을 그대로 정렬해버리면
> (무게 1, 가격 65 ) < (무게 2, 가격 99) < (무게 5, 가격 23)

이와 같은 형태가 되고, 이 상황에서 가방은 무게 2와 무게 10이므로, 우리는 직관적으로 65라는 가격이 23보다 크니까 무게 5짜리보다 무게 1을 담는 것이 당연하다. 하지만, 정렬에서 그런 것을 따지기란 어렵다.

정렬을 이렇게 해 놓고, 위에서부터 무게 순서대로 내려오면서 가방에 들어갈 수 있는 것을 넣는다고 하면,
- 무게 5, 가격 23의 보석은 무게 10의 가방에 들어간다.
- 무게 2, 가격 99의 보석은 무게 2의 가방에 들어간다.

이런 상황이 발생하며 무게 1, 가격 65의 보석이 무게 5, 가격 23의 보석보다 가격이 높음에도 선택되지 않는 상황이 발생한다. 그러니까, 우리는 각 가방에 대해서 들어갈 수 있는 보석들을 따로 체크하고, 그들 중에서 또 가격이 가장 높은 보석을 담아야 한다는 것을 알 수 있다.


### 정렬의 아이디어 - 가방과 보석을 같이?
만약, 저 위의 경우를 가방과 보석을 아예 같이 정렬해버린다면 어떨까?

- 무게 1, 65 가격의 보석
- 무게 2, 99 가격의 보석
- 무게 2의 가방
- 무게 5, 23 가격의 보석
- 무게 10의 가방

다음과 같이 정렬된 상태에서, 위에서부터 순차적으로 내려오면, 어떤 특정 가방을 만나기 전까지 만나는 모든 보석은 그 가방 내에 들어갈 수 있는 보석임을 알 수 있다.

그러면 이 순서에서,
- 무게 2의 가방에 들어갈 수 있는 보석
  - 무게 1, 무게 2 중에서 가장 가격이 높은 건 99
- 무게 5의 가방에 들어갈 수 있는 보석
  - 무게 1, 무게 2, 무게 5 모두 들어갈 수 있지만, 무게 2는 이미 넣었음
  - 그러므로 무게 1과 무게 5 중에서 가장 높은 것은 65

따라서 99+65=164가 답이 되는 것을 알 수 있다. 그러니까, 이 과정을 구현한다고 했을 때

- 가방과 보석을 모두 **무게 중심으로** 정렬한다.
- 정렬한 결과를 작은 무게부터 확인하면서 올라가며, 가방이 아닌 보석들은 또 따로 **가격 중심으로** 정렬한다.
- 확인하는 과정에서 '가방'이 나온다면 **가격 중심으로 정렬된 상태의 보석 중 가장 가격이 높은 것**&ZeroWidthSpace;을 선택하여 가방에 집어넣는다.

이와 같은 과정으로 진행 가능하다는 것을 알 수 있다. 이때, 자료의 양이 굉장히 많음과 동시에 ($N$과 $K$가 30만 이하) 보석의 정렬 상태가 항상 유지되어야 한다는 점에서 우리는 우선순위 큐(힙)을 사용하는 것이 좋다는 것을 판단할 수 있다.

---

## 코드화
### 가방과 보석의 입력 처리
```java
public class Main {
    static int N, K;

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        N = Integer.parseInt(st.nextToken());
        K = Integer.parseInt(st.nextToken());

        PriorityQueue<int[]> jewelAndBag = new PriorityQueue<>((o1, o2) -> {
            if (o1[0] != o2[0])
                return o1[0] - o2[0];
            else return o2[1] - o1[1];
        });
        
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            jewelAndBag.add(new int[] {Integer.parseInt(st.nextToken()), Integer.parseInt(st.nextToken())});
        }

        for (int j = 0; j < K; j++)
            jewelAndBag.add(new int[] {Integer.parseInt(br.readLine()), -1});
```
`PriorityQueue`를 사용하여 가방과 보석을 일단 일괄적으로 정렬한다. 정렬 규칙을 새로 lambda expression으로 지정하였다.

```java
(o1, o2) -> {
	if (o1[0] != o2[0])
		return o1[0] - o2[0];
    else return o2[1] - o1[1];
}
```
우선순위 큐 아래에서 입력을 받는 것을 보면 `StringTokenizer`로 순서대로 받아오기 때문에, 0번 인덱스가 무게, 1번 인덱스가 가격임을 알 수 있다. 이때, 가방의 가격은 `-1`로 지정하여 보석이 아님을 명확히 한다.

그렇게 하면 람다식에 의하여 무게가 같지 않으면 무게 중심으로 오름차순 정렬, 무게가 같으면 **가격 중심으로 내림차순** 정렬이 되고 있음을 알 수 있게 된다.

### 가방에 넣을 보석을 처리하는 부분
```java
		...
        PriorityQueue<Integer> values = new PriorityQueue<>(Collections.reverseOrder());
        long result = 0;

        while (!jewelAndBag.isEmpty()) {
            int[] obj = jewelAndBag.poll();
            if (obj[1] != -1) values.offer(obj[1]);
            else if (!values.isEmpty()) result += values.poll();
        }

        System.out.println(result);
    }
}
```
안에 있는 모든 가방과 보석이 `isEmpty()` 메소드에 의하여 없을 때까지 `int[] obj` 형태로 가방 혹은 보석의 배열을 받아온다.

만약, `-1`이라는 가격이 저장되어 있다면 가방이므로, 그렇지 않은 경우에 한태서 `values`라는 `PriorityQueue`에 가격을 모두 저장한다. 이때, 정렬 규칙을 `Collections.reverseOrder()`로 지정하여 내림차순으로 한다면, `poll()`을 통해 꺼내면 최댓값이 나오는 최대 힙 구조가 만들어진다.

이 과정에서 `!values.isEmpty()` 조건을 달아줘야 하는데, 어떤 가방의 가능 무게가 매우 작아서 보석을 담을 수 없을 가능성도 있기 때문이다. 그래서, 만약 보석을 담을 수 없다면 `if-else if`에 의하여 완전히 걸러지고 `while`을 순회할 것이며, 보석을 담을 수 있다면 최대 힙에서 가장 높은 가격의 보석을 꺼내주면 된다. 이때, 방법 고안 파트에서 적었듯 이 안에 들어가는 것들은 이전 `PriorityQueue`인 `jewelAndBag` 내의 정렬에 의하여 가방 안에 들어갈 수 있는 무게만이 들어가기 때문에 값을 그저 받아오기만 하면 된다.

그렇게 가방에 담게 되는 선택된 보석들의 가격만 `result`에 합쳐주면, 그 값이 답이 된다.

## 정리
`PriorityQueue`를 두 번 활용하여 간단한 방식으로 풀 수 있는 문제였지만, 사실상 이 아이디어를 떠올리지 못하면 배열이나 리스트의 정렬로서 풀려고 하다가 시간 초과를 겪기 쉬운 문제였다.
