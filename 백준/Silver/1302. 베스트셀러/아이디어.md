# 아이디어
중복되는 것이 몇 번 등장하는지 파악하는 동시에, 정렬도 수행하기 위해서 어떤 걸 쓸 수 있을까? 물론 한 가지 방법으로 풀 수 있는 건 아닐 것!

## 문제 파악하기
오늘 하루 동안 팔린 책의 제목이 입력으로 들어오면, 가장 많이 팔린 책의 제목을 출력하자.

입력은 다음과 같다:
- 첫째 줄에 오늘 하루 동안 팔린 책의 개수 $N$이 1000 이하의 자연수로 주어진다.
- 둘째 줄부터 $N$개 줄에 걸쳐 책의 제목이 입력으로 주어진다.
- 책의 제목 길이는 50 이하 길이의, 알파벳 소문자로만 구성된 문자열이다.

출력으로 첫째 줄에 가장 많이 팔린 책의 제목을 출력하되, 가장 많이 팔린 책이 여러 개일 경우 사전 순으로 가장 앞서는 제목을 출력한다.

## 방법 고안
여기에서 사용할 방법으로 해시 맵 방식을 소개한다.

### 정렬을 해야 하는데 왜 해시 맵?
중복을 체크하면서 문자열을 처리할 수 있는 방법으로서 선택한 것이 바로 해시 맵이다. 물론, `class`를 하나 설정하여, 내부 필드로 `int`와 `String`을 두고 책 이름과 나온 횟수를 설정할 수도 있겠지만 아예 `HashMap`을 사용하였다.

입력을 받아 책 이름을 `key`로, 나온 횟수를 `value`로 설정하여, `HashMap<String, Integer>`의 형태로 처리하면 문자열의 횟수를 저장하고 처리하는 데 효과적이라고 판단하였고, 가장 간단한 방법으로 생각이 났다.

### 그래서 정렬은 어떻게 하는데?
`HashMap`의 정렬은 `key`와  `value`에 따른 방법이 있는데, 그 중 `value`에 착안해서 보도록 하자. `Comparator` 정렬 규칙을 선언하여 `compare`하거나, 또는 Lambda Expression으로도 해결 가능하다.

우선 `HashMap.keySet()`을 사용하면 `key` 값들을 하나의 `List`로 뽑아내는 것이 가능하다. 그렇게 하여 하나의 `ArrayList`를 생성하여, 그것을 정렬하는 것이다.

```java
Map<K, V> map = new HashMap<>();
List<K> keySet = new ArrayList<>(map.keySet());
keySet.sort(new Comparator<K>() {
	@Override
    public int compare(Object o1, Object o2) {
    	return map.get(o1).compareTo(map.get(o2));
    	// 여기에서 대강 Value 값을 비교하면 된다
    }
});
```

이렇게 정렬한 상태로, 필요하게 된다면 그 리스트를 기반으로 하여 `map.get(key)`로 출력하든, 값을 가져오든 하면 되겠다.

이걸 람다식으로 할 수도 있다.
```java
keySet.sort((o1, o2) -> map.get(o2).compareTo(map.get(o1)));
```
---

이 점에 착안하여 코드를 짜면 되겠다.


## 코드화
### 입력 처리 및 해시 맵 구조화
```java
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringBuilder out = new StringBuilder();

        int N = Integer.parseInt(br.readLine());
        Map<String, Integer> bookSet = new HashMap<>();
        for (int i = 0; i < N; i++) {
            String bookName = br.readLine();
            if (bookSet.containsKey(bookName))
                bookSet.replace(bookName, bookSet.get(bookName) + 1);
            else bookSet.put(bookName, 1);
        }
```

입력을 받아서 `HashMap.containsKey()` 메소드를 활용해 해당 책 이름이 있으면 값을 받아 1 추가하기 위해 `HashMap.replace()`를 사용한다. 만약, 책이 처음 나온 거라면 `HashMap.put()`을 사용하여 `value` 값을 1로 한다.

### 정렬 및 출력
```java
		...
        List<String> keySet = new ArrayList<>(bookSet.keySet());
        keySet.sort(new Comparator<String>() {
            @Override
            public int compare(String book1, String book2) {
                if (!bookSet.get(book1).equals(bookSet.get(book2)))
                    return bookSet.get(book1).compareTo(bookSet.get(book2));
                // 개수 중복이 없다면 last index에 답이 올 것
                else return book2.compareTo(book1);
                // 개수 중복이 있어도 last index에 답이 오려면 사전 역순 정렬 필요
            }
        });

        bw.write(keySet.get(keySet.size() - 1));
        bw.flush();
    }
}
```

`HashMap.keySet()`으로 `key` 값들을 `List<String>`으로 만들어 뽑아내고, 이들을 개수 기준으로 정렬한다. 모든 책의 등장 횟수가 다르다면 가장 많이 나온 책이 맨 뒤에 나오게 된다. 하지만 등장 횟수가 중복될 가능성도 있고 그런 경우 사전 순서대로 가장 앞에 오는 책 이름을 뽑아내야 한다.

그래서, 맨 뒤 인덱스를 고정적으로 뽑아 출력하기 위해 개수 중복이 있다면 사전 역순으로 정렬하게 한다. `obj1.compareTo(obj2)`에서 `obj1`, `obj2`의 순서 변경을 통해 `compare()` Method Overriding에 있어 오름차순과 내림차순 변경이 가능함을 사용하자.

정렬을 그렇게 했기 때문에 맨 마지막에 출력은 `get()` 메소드를 통해 맨 마지막에 있는 인덱스 키 값을 가져오면 된다.

## 정리
물론 다른 것을 사용하는 방법도 있다. 설명 중에도 말했듯, 구조체 같은 느낌으로 클래스를 하나 지정하여 배열에 넣고 정렬 규칙을 활용하는 방법도 있겠다.
