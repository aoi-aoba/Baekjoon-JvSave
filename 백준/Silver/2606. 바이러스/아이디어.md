# 아이디어
그래프 탐색을 하는 가장 기본적인 그래프 문제이다. BFS, DFS 둘 중 어느 쪽이든 사용하기만 하면 된다.

## 문제 파악하기
신종 바이러스인 웜 바이러스는 네트워크로 전파되어 한 컴퓨터가 이 바이러스에 걸리면 그 컴퓨터와 네트워크 상 연결된 모든 컴퓨터가 바이러스에 감염된다.

![](https://velog.velcdn.com/images/aoi-aoba/post/86c03acf-f558-4986-99fc-c6360241826f/image.png)

위 그림과 같이 네트워크 상에 연결되어 있는 컴퓨터 7대가 있다. 그렇다면 1번 컴퓨터가 웜 바이러스에 걸린다면 2번, 5번 컴퓨터를 지나 3번과 6번 컴퓨터까지 전파되지만, 4번과 7번은 그 어떤 연결도 없기 때문에 영향을 받지 않아 1번 컴퓨터를 통해 2, 3, 5, 6번의 총 4대 컴퓨터가 웜 바이러스에 감염된다.

1번 컴퓨터가 웜 바이러스에 걸린다면, 이 컴퓨터를 통해 바이러스에 걸리는 컴퓨터는 몇 대인지 파악하는 프로그램을 작성하자.

---

입력은 다음과 같이 주어진다:
- 첫째 줄에는 컴퓨터의 수가 100 이하의 자연수로 주어진다.
- 각 컴퓨터가 1번부터 차례대로 번호가 매겨진다.
- 둘째 줄에는 네트워크 상에서 직접 연결된 컴퓨터 쌍의 수가 주어진다.
- 이어서, 둘째 줄에 주어진 쌍의 수만큼 한 줄에 한 쌍씩 서로 직접 연결되어 있는 컴퓨터 번호 쌍이 주어진다.

이때, 1번 컴퓨터가 바이러스에 감염되면 이 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터 수를 첫째 줄에 출력하자.

## 방법 고안
DFS나 BFS 어느 쪽이든 관계 없이, 그래프를 탐색해서 돌기만 하면 된다. 크게 설명이 필요가 없다. 1번 노드를 중심으로 하여 간선들을 돌면서 닿을 수 있는 모든 곳을 확인한 뒤, 그 개수를 출력하면 된다.

## 코드화
### DFS 로직
```java
public class Main {
    public static final List<List<Integer>> graph = new ArrayList<>();
    public static boolean[] dfsVisited;
    public static int infectedCnt = 0;

    public static void dfs(int startNode) {
        dfsVisited[startNode] = true;
        infectedCnt++;

        for (int node : graph.get(startNode))
            if (!dfsVisited[node]) dfs(node);
    }
```

각각의 노드에 대해 갈 수 있는 모든 노드를 `List<Integer>`로 저장하여 그래프는 `List<List<Integer>>` 형태로 저장된다. 방문한 곳을 다시 방문하지 않기 위하여 `boolean[] dfsVisited` 배열을 만들어주었고, 개수를 세기 위해 `infectedCnt`라는 변수를 두었다.

`dfs` 로직은 다음과 같이 진행한다.
- `dfsVisited[]` 배열에서 해당 `startNode`를 방문했다고 `true`로 기록하고, `infectedCnt`를 1 증가시킨다.
- 해당 노드에 대하여 방문할 수 있는 이웃 노드들을 가져온다. `graph.get(startNode)`의 형태로 받아오면 그 리스트를 enhanced-for Loop를 활용하여 하나씩 확인하고, 방문하지 않은 곳이라면 `dfs(node)`를 통해 재귀호출하여 방문한다.

### main 메소드
```java
	...
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int node = Integer.parseInt(br.readLine()), line = Integer.parseInt(br.readLine());
        dfsVisited = new boolean[node + 1];

        for (int i = 0; i <= node; i++) graph.add(new ArrayList<>());
        for (int i = 0; i < line; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int node1 = Integer.parseInt(st.nextToken()), node2 = Integer.parseInt(st.nextToken());
            graph.get(node1).add(node2);
            graph.get(node2).add(node1);
        }

        for (int i = 0; i <= node; i++)
            Collections.sort(graph.get(i));

        dfs(1);
        bw.write(String.valueOf(infectedCnt - 1));
        bw.flush();
    }
}
```

이제 할 일은 각각의 값을 받아 DFS를 돌리기만 하면 된다.
- `node`와 `line`은 각각 정점과 간선의 개수이다.
- `dfsVisited`는 0 인덱스를 사용하지 않기 때문에 `node+1`의 크기를 가져야 1번부터 번호를 매길 수 있다.

0번 인덱스는 사용하지 않는다고 하였기 때문에 `node` 번호까지 for 문을 돌려서 그래프 기반을 마련하고, `line`의 개수만큼 for 문을 돌려서 각각의 간선을 모두 추가해준다. 이때, 네트워크 상 연결된 두 컴퓨터가 서로 감염이 되게 할 수 있다는 점에서 두 개의 `node1`과 `node2`에 대해 서로의 방향으로 나아갈 수 있다는 방식으로 표현하기 위하여

```java
graph.get(node1).add(node2); // node1 -> node2의 간선
graph.get(node2).add(node1); // node2 -> node1의 간선
```
두 개의 유향 간선을 추가해주었다.

> **Collections.sort()를 사용하면 왜 시간이 더 빨라질까?**   
> 일반적으로 생각했을 때 굳이 순서대로 돌아야 할 필요도 없는 문제이기도 하고, 정렬의 의미가 크게 없는 문제인데 왜 이것을 사용하면 시간이 조금 더 빨라진다거나 메모리가 덜 사용된 기록을 볼 수 있을까? 대부분은 자바에서의 메모리 접근 패턴과 캐시 효율로 설명 가능하다.   
> 정렬이 없는 경우에는 노드들이 각각 입력 순서 그대로 저장되고, 입력 순서가 보장되지 않으므로 인접 노드 순회에 대해 임의 인덱스를 자주 접근하여 `visited[]` 배열의 메모리 접근 패턴이 불규칙하지만 정렬을 진행하면 **인접 리스트가 오름차순으로 정렬**&ZeroWidthSpace;되어 있기 때문에 낮은 인덱스부터 순서대로 접근 가능하여 **CPU 캐시 히트율이 좋아지고 분기 예측도 잘 맞아**&ZeroWidthSpace;서 성능이 좋아진다. 그 결과 잘못된 예측으로 인한 **파이프라인 플러쉬**&ZeroWidthSpace;를 줄일 수 있다. 그리고, 정렬함에 따라 연속된 인덱스를 빠르게 접근하는 패턴이 생겨서 **CPU prefetcher가 미리 데이터를 가져오는** 효과로 미세하게 속도 차이를 만들 수 있다.

시간 복잡도로서는 $O(E \log E)$가 추가되지만 캐시와 분기 예측으로 인해 실제 벽시계 시간이 빨라질 수 있다. 아무튼, 그렇게 정렬한 뒤 1번 컴퓨터부터 DFS를 돌려준 뒤, `infectedCnt`를 출력하면 된다. 이때, 1을 빼주는 것은 1번 컴퓨터는 이미 '감염된' 상태이며 이 컴퓨터를 통해 **추가적으로 감염되는 컴퓨터의 대수**&ZeroWidthSpace;를 출력하는 것이 문제의 포인트이다.


## 정리
BFS와 DFS를 사용하는 가장 기본적인 문제 중 하나라고 볼 수 있다. 아래처럼 코드를 짜면 BFS로도 풀 수 있다.

```java
public class Main {
    public static final List<List<Integer>> graph = new ArrayList<>();
    public static boolean[] bfsVisited;
    public static int infectedCnt = 0;

    public static void bfs(int startNode) {
        Queue<Integer> queue = new ArrayDeque<>();
        queue.offer(startNode);
        bfsVisited[startNode] = true;

        while (!queue.isEmpty()) {
            int current = queue.poll();
            infectedCnt++;

            for (int node : graph.get(current)) {
                if (!bfsVisited[node]) {
                    bfsVisited[node] = true;
                    queue.offer(node);
                }
            }
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        int node = Integer.parseInt(br.readLine()), line = Integer.parseInt(br.readLine());
        bfsVisited = new boolean[node + 1];

        for (int i = 0; i <= node; i++) graph.add(new ArrayList<>());
        for (int i = 0; i < line; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            int node1 = Integer.parseInt(st.nextToken()), node2 = Integer.parseInt(st.nextToken());
            graph.get(node1).add(node2);
            graph.get(node2).add(node1);
        }

        for (int i = 0; i <= node; i++)
            Collections.sort(graph.get(i));

        bfs(1);
        bw.write(String.valueOf(infectedCnt - 1));
        bw.flush();
    }
}
```
