https://csacademy.com/app/graph_editor/

# 아이디어
포화 이진 트리에 대해 알지 못해도 풀 수 있는 단순한 수학 문제

## 문제 파악하기
Lovisa는 KTH에서 Stefan의 포화 이진 트리에 대한 수업을 듣고 있다. 하지만 Lovisa는 이미 수업 내용을 알고 있어서 지루하다. Stefan은 그런 Lovisa에게 트리에 대해 새로운 과제를 내 주었다.

먼저, 포화 이진 트리에 숫자를 아래 그림처럼 매긴다. 맨 밑 가장 오른쪽의 리프 노드부터 1로 시작하여 각 노드에 매기는 숫자는 같은 레벨에서는 오른쪽부터 왼쪽 순서대로 숫자를 매긴다. 한 레벨에 대해 숫자를 매기는 것을 마치면, 그 레벨 바로 위 가장 오른쪽 노드로 이동하여 똑같이 오른쪽부터 왼쪽 순서로 끝까지 모두 숫자를 매긴다. 이 과정을 루트 노드에 도착할 때까지 반복한다.

트리에 대한 노드를 표현할 때, 루트 노드에서부터 리프 노드에까지 아래로 내려가는 화살표를 그려 경로를 표현하자. 루트 노드와 각각의 내부 노드(*리프 노드가 아닌 노드)는 각각 왼쪽 혹은 오른쪽으로 갈 수 있다. 이걸 $L$과 $R$로 표현하자.

![](https://velog.velcdn.com/images/aoi-aoba/post/e59e4d7f-4d4a-42c8-8fe9-cefef7107467/image.png)

**위 그림은 높이가 3인 포화 이진 트리에 번호를 매긴 것으로 경로 $LR$은 11번 노드로, $RRL$은 2번 노드로 향하게 되며 루트 노드는 15이다.**

Lovisa가 해야 하는 과제는 포화 이진 트리의 높이와 루트 노드에서 향하게 될 경로가 주어질 때, 해당 노드의 번호를 구하는 것이다.

---

입력은 다음과 같이 주어진다:
- 입력은 한 줄에 포화 이진 트리의 높이와 루트 노드에서 향하게 되는 경로가 공백으로 구분되어 주어진다.
- 포화 이진 트리의 높이 $H$는 30 이하의 자연수이다.
- 경로 문자열은 $L$과 $R$만을 포함하는 루트 노드에서부터 시행하는 순서대로 적힌 문자열이다.
- $L$은 좌측 자식 노드, $R$은 우측 자식 노드를 의미한다.
- 입력에 경로 문자열 없이 높이 $H$만 주어질 수도 있다.

출력은 주어진 경로로 향했을 때 해당 노드의 번호를 출력하자.

## 방법 고안
포화 이진 트리에 대한 이해도가 있어도, 없어도 풀 수 있다.

### 포화 이진 트리 (Perfect Binary Tree)
계층적 관계를 표현하는 비선형적 자료구조인 트리는 한 노드(루트 노드라고 한다)로부터 시작하여 여러 자식 노드로 뻗어나가는 나무와 같은 형태를 가진다. 이때, 이 트리의 각 노드가 왼쪽 자식과 오른쪽 자식 노드 두 개만을 가질 수 있을 때 이를 이진 트리라고 한다. 이러한 이진 트리 중에서 리프 노드를 제외한 모든 노드가 두 개의 자식 노드를 가지고 있을 때를 포화 이진 트리라고 한다.

![](https://velog.velcdn.com/images/aoi-aoba/post/3e941cfa-25b9-4eae-9a53-73accd0a04b2/image.png)

위와 같은 모양으로 점점 가지를 뻗어 내려가는 것인데, 아래로 내려갈 수록 노드의 개수는 두 배가 된다. 루트 노드로부터 2개씩 늘어가는 것이기 때문에 초항이 1이고 공비가 2인 등비수열의 합으로서 전체 노드의 개수를 구할 수 있고 이는 결국 높이 $h$에 대하여 $2^{h+1}-1$의 형태로 나타남을 자명하게 알 수 있다.

### 왼쪽 노드로 갈 때와 오른쪽으로 갈 때의 경우
굳이 문제에서 위에서부터 아래로 내려가면서 숫자를 매겼다고 해서 그걸 곧이곧대로 따라갈 필요는 없다. 반대로 위에서부터 1, 왼쪽에서 오른쪽의 방향으로 채워나간다고 생각해서 루트 노드에서 리프 노드로 내려가는 방향으로 채운다고 생각해보자. 그렇다면

![](https://velog.velcdn.com/images/aoi-aoba/post/5680b1d3-1c43-406e-98d4-86252aa9cdce/image.png)

위 그림과 같이 채워질 수 있다. 이 과정에서 왼쪽 노드로 내려가는 과정과 오른쪽 노드로 내려가는 과정을 각각 살펴보면 규칙성을 쉽게 발견할 수 있다. 왼쪽 방향의 자식 노드로 내려간다면 값이 2배가 되고, 오른쪽 방향으로 내려간다면 값을 2배하고 1을 더한 값이 된다는 것을 알 수 있다.

이걸 역으로 채운다는 것이기 때문에, 루트 노드에는 어차피 노드의 개수가 적힐 것이므로
> (전체 노드의 개수) - (루트 노드부터 1번 인덱스라 할 때, 해당 노드의 인덱스 번호) + 1

의 형태로 해당 노드에 적히는 번호를 알 수 있다. +1을 하는 것은 1-based index 때문임을 이해할 수 있을 것이다.

---

## 코드화
### 전체 코드
```java
public class Main {
    public static long pow(long base, long exp) {
        long res = 1;
        for (int i = 0; i < exp; i++)
            res *= base;
        return res;
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] input = br.readLine().split(" ");

        long max = pow(2, Integer.parseInt(input[0]) + 1) - 1;
        int idx = 1;
        if (input.length != 1) {
            char[] path = input[1].toCharArray();
            for (char ch : path)
                idx = idx * 2 + (ch == 'R' ? 1 : 0);
        }

        System.out.println(max - idx + 1);
    }
}

```
매우 아무렇지 않게 계산해주면 된다. 사실 루트 노드에 적히는 값인 `max`의 값은 굳이 저렇게 함수를 선언해주지 않아도 되긴 한다.

```java
long max = (long) Math.pow(2, Integer.parseInt(input[0]) + 1) - 1;
```

정도면 충분히 계산할 수 있을 것이다. 그리고 `idx`를 1로 시작해서 공백을 통해 구분한 `input`이 만약 길이가 1이라면 뒤에 path가 주어지지 않은 것이므로, 그렇지 않은 경우만 `input[1]`을 `toCharArray()`를 활용해 `char` 배열로 바꿔준 다음 enhanced-for loop를 활용하여 기존 `idx`를 2배 하고 `ch` 값이 `R`일 때만 1을 더해주는 방식으로 계산한다.

마무리는 얘기했던 대로 `max`에서 `idx`를 빼고 1을 더해주면 끝.

## 정리
완전 이진 트리의 성질을 알고 있다면 접근하기 조금 더 쉬웠을 것이라는 정도. 그게 아니어도 트리를 몰라도 사실 풀 수 있는 단순 수학 문제였기 때문에...
