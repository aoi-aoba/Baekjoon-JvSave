# 아이디어
재귀는 결국 분할 정복, 분할 정복은 결국 재귀. 반복되는 구조가 보이고, 그걸 작게 나눠서 해결할 수 있다는 것이 이 문제의 포인트.

## 문제 파악하기
칸토어 집합은 0과 1사이의 실수로 이루어진 집합으로, 구간 [0, 1]에서 시작해서 각 구간을 3등분하여 가운데 구간을 반복적으로 제외하는 방식으로 만든다.

전체 집합이 유한이라고 가정하고, 다음과 같은 과정을 통해서 칸토어 집합의 근사를 만들어보자.

1. -가 3N개 있는 문자열에서 시작한다.

2. 문자열을 3등분 한 뒤, 가운데 문자열을 공백으로 바꾼다. 이렇게 하면, 선(문자열) 2개가 남는다.

3. 이제 각 선(문자열)을 3등분 하고, 가운데 문자열을 공백으로 바꾼다. 이 과정은 모든 선의 길이가 1일때 까지 계속 한다.

예를 들어, N=3인 경우, 길이가 27인 문자열로 시작한다.
```
---------------------------
```

여기서 가운데 문자열을 공백으로 바꾼다.
```
---------         ---------
```

남은 두 선의 가운데 문자열을 공백으로 바꾼다.
```
---   ---         ---   ---
```

한번 더
```
- -   - -         - -   - -
```
모든 선의 길이가 1이면 멈춘다. N이 주어졌을 때, 마지막 과정이 끝난 후 결과를 출력하는 프로그램을 작성하시오.

- 입력은 여러 줄로 이루어져 있고, 파일의 끝(EOF)에서 입력을 멈추며 각 줄에는 0 이상 12 이하의 정수 $N$이 적혀 있다.
- 출력은 각 입력 $N$에 대하여 해당하는 칸토어 집합의 근사를 출력한다.

## 방법 고안
작게 나눠서 생각해보자. 문제 하나하나를 더 작은 문제로 나누는 것이다. 아래에 그 설명을 적어보려 한다.

### 작은 문제로 나눌 수 있는가?
너무 당연한 이야기지만, 가능하다. $3^N$의 문자열에서 가운데 문자열을 공백으로 나눈다는 것은 길이 $3^{N-1}$의 중간 문자열을 찾아낸다는 것이다. 즉, one-based index를 기반으로 할 때 $3^{N-1}+1$부터 $2 \times 3^{n-1}$번째 까지는 공백이 된다.

- $N=1$일 때, 위에 의하여 2부터 2까지가 공백이 된다.
- $N=2$일 때, 위에 의하여 4부터 6까지가 공백이 된다.

이와 같이 진행되는데, 직접 보면
- $N=1$일 때
```
- - 
// 중간 두 번째 칸은 공백임
```
- $N=2$일 때
```
- -   - -
// 전체 길이로 볼 때 앞뒤는 무시하고, 중간 4~6번째 칸은 공백임
```
이라고 볼 수 있다.

그리고, 그 앞뒤에 대해서 길이를 또 하나 줄여서 위의 방법을 다시 적용하는 것을 볼 수 있다. 예를 들어 $N = 2$에 대하여 중간 4~6번째 칸을 비우고, 앞 뒤에 대하여 $N=1$이 적용될 수 있으므로 이를 다시 적용하는 것을 볼 수 있다.

이를 활용하여, 계속 작은 문제로 나눠서 출력하는 방식으로 코드를 짜면 된다.

## 코드화
### threePow, make, converToStr 메소드
```java
public class Main {
    public static int threePow(int n) {
        if (n == 0) return 1;
        return 3 * threePow(n - 1);
    }
    public static String make(int n) {
        if (n == 0) return "-";
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 3; i++) sb.append(make(n - 1));
        return sb.toString();
    }
    public static String convertToStr(char[] str) {
        StringBuilder sb = new StringBuilder();
        for (char ch : str) sb.append(ch);
        return sb.toString();
    }
```

- `threePow(int n)` 메소드는 `Math.pow(double a, double b)`를 사용할 수도 있지만 `int`형 재귀를 위해 별도로 만들어주었다. $3^n$을 계산하는 용도이며, 입력 범위에 의해 $3^{12}$까지 들어갈 수 있고 이는 100만 이하의 값이다.

- `make(int n)` 메소드는 $3^n$ 길이의 `-` 문자열을 만들어준다. `StringBuilder`를 사용해 `StringBuilder.toString()` 메소드로 `String` 형태로 `return`하게 했다.

- `converToStr(char[] str)`의 경우, `String.toCharArray()`로 `char[]` 배열로 변경된 것을 다시 `String`으로 변환하는 작업을 해 준다. `String`의 값을 변경하기 위하여 `char[]`로 바꿔 코드를 진행하기 때문에, 마지막 출력을 위하여 이것을 다시 `String`으로 바꾸는 것이다.

### cantorSet 메소드
```java
	...
    public static String cantorSet(int n, char[] str) {
        if (n == 0) return "-";
        if (n == 1) return "- -";

        int m = threePow(n - 1);
        for (int i = 0; i < m; i++) str[m + i] = ' ';
        // 입력 n에 대하여 3^(n-1)부터 2*3^(n-1)-1은 공백처리 필요

        String part = make(n - 1);
        part = cantorSet(n - 1, part.toCharArray());
        // 입력 n에 대하여 0~3^(n-1)-1 부분과 2*3^(n-1)~3^n-1까지는 서로 같은 모양임
        // m = 3^(n-1)로 대체했으므로 이 구간이 0~m-1, 2m~3m-1로 표현할 수 있음

        for (int i = 0; i < m; i++) str[i] = part.charAt(i);
        for (int i = 0; i < m; i++) str[2 * m + i] = part.charAt(i);
        return convertToStr(str);
    }
```
- $N = 0$일 때와 $N = 1$일 때는 문자열을 직접 `return`해준다.

- 우선, $3^{N-1}$의 값을 $M$으로 두자. 그러면, 우리가 전체 길이에 대하여 $3^{N-1}$부터 $2 \times 3 ^ {N-1} - 1$까지는 공백 처리가 필요하다 (여기서는 zero-based index임에 주의하자)

- 그리고 그 앞 뒤를 계속 재귀적으로 분할하여 처리해야 하므로, `part`라는 `String`을 `make()`로 만들고, `cantorSet()`을 하나 작은 크기로 다시 호출한다.

- 계속 재귀적으로 `part`가 만들어질 것이고, 우리는 그것을 `str[]`에 변환해줘야 한다. 입력 $N$에 대하여 $0$부터 $3^{N-1}-1$ 부분과 $2 \times 3^{N-1}$ 부터 $3^N-1$까지는 서로 같은 모양인데 (zero-based index 주의) 여기에서 우리가 위에 $M = 3^{N-1}$이라고 했으므로 $0$부터 $M$까지, 그리고 $2M$부터 $3M-1$까지라고 단순화할 수 있다.

- 그래서 이렇게 바뀐 `str[]`은 `String.toCharArray()`로 배열 형태이기 때문에 `convertToStr()`을 통해 `String` 형태로 반환한다.

### main
```java
	...
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        StringBuilder out = new StringBuilder();

        while (true) {
            String str = br.readLine();
            if (str == null) break;

            int N = Integer.parseInt(str);
            String result = make(N);

            result = cantorSet(N, result.toCharArray());
            out.append(result).append("\n");
        }

        bw.write(out.toString());
        bw.flush();
    }
}
```
메인 메소드에서는 그저 입력을 받아서, `EOF`가 나타나기 전까지 계속 `make(N)`을 먼저 돌린 뒤 `cantorSet()`으로 돌려주면서 반복하여 `StringBuilder`에 넣어준다. 그리고 출력해주면 된다.
