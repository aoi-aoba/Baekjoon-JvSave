# 아이디어
누가 봐도 자료구조 문제! 누가 봐도 어떤 자료구조를 써야 할지도 뻔한데! 근데 쉽진 않다!

## 문제 파악하기
4개의 기호 `(`, `)`, `[`, `]`를 사용하여 괄호열을 만든다.

- 한 쌍의 괄호로만 이뤄진 `[]`와 `()`는 올바른 괄호열이다.
- 만일 `X`가 올바른 괄호열이라면 `[X]`와 `(X)` 역시 올바른 괄호열이다.
- `X`와 `Y`가 모두 올바른 괄호열이면 `XY`처럼 결합해도 올바른 괄호열이다.

올바른 괄호열 규칙으로서, `(()[[]])`라던가 `(())[][]`는 올바른 괄호열이지만 `([)]`라던가 `(()()[]`는 올바른 괄호열이 아니다. 우리는 올바른 괄호열에 대하여 그 괄호열의 값을 '괄호값'이라 하고, 다음과 같이 계산한다.

- `()`인 괄호열의 값은 2이고, `[]`인 괄호열의 값은 3이다.
- `(X)` 괄호값은 `X`의 괄호값의 2배이며, `[X]` 괄호값은 `X` 괄호값의 3배로 계산한다.
- 올바른 괄호열이 `XY`처럼 결합하였을 때는 괄호값은 각 `X`와 `Y` 괄호값의 합으로 계산한다.

예를 들어, `(()[[]])([])`의 괄호값은 28이다.

---
입력으로 괄호열을 나타내는 문자열이 주어지고, 그 길이는 1 이상 30 이하로 주어진다. 첫째 줄에, 그 괄호열의 값을 나타내는 정수를 출력하자. 만일 입력이 올바르지 못한 괄호열이면 반드시 0을 출력하자.

## 방법 고안
경우의 수에 따라서 처리할 방법이 조금씩 달라진다는 것을 염두에 두어야 한다.

### 어떤 방식으로 접근해야 할까?
들어오는 괄호들에 대해서, 이전에 `[`가 존재했을 때 `]`가 들어온다면 두 개를 합쳐 `3`이라는 값이 되고 두 괄호를 없앤다. `(`가 존재하지 않을 때 `)`가 들어온다면, 이 괄호는 없앨 수 없다. 즉, 이런 구조 하에서 보았을 때 이전의 값은 계속 저장해두면서 처리되는 괄호들은 바로바로 없앨 수 있어야 한다. 자료구조로서 `Stack`이 가장 유력한 선택일 것이다.

### 구분해야 할 경우들이 있다고?
그냥 곧이곧대로 이전에 `[`가 있고 바로 뒤에 `]`가 들어오면 빼서 처리하는 방식 같은 방법으로 처리하면 좋겠지만, 그렇지 않은 예시들도 있고, 그 값을 처리할 방법도 마땅치 않은 것이 이 문제의 포인트이다. 생각해볼 것들을 아래에 제시해보려 한다. 아래에 제시된 것들은, 실제로 코드를 짜면서 내가 생각을 거친 부분들이다.

### 숫자로 인정하는 부분은 그렇다 쳐도, 곱셈과 덧셈은 어떻게 구분할까?

```java
        for (int i = 0; i < input.length(); i++) {
            if (input.charAt(i) == ')') {
                if (stack.peek() == '(') {
                    stack.pop();
                    if (numInsideBracket == 0 && stack.isEmpty()) {
                        numInsideBracket += 2;
                        result += numInsideBracket;
                        numInsideBracket = 0;
                    } else if (numInsideBracket != 0 && stack.isEmpty()) {
                        result += numInsideBracket * 2;
                        numInsideBracket = 0;
                    } else if (numInsideBracket == 0){
                        numInsideBracket += 2;
                    } else numInsideBracket *= 2;
                    ...
```

초기에 짠 코드를 위에 첨부해보았다.

처음에는 그냥 `numInsideBracket` 같은 변수를 주어서, 다른 괄호의 안에 있다면 `numInsideBracket`에 값을 넣고, 괄호 바깥으로 처리되었으면 `result`에 합하는 방식으로 덧셈을 처리하려 하였다. 하지만, 그건 쉽지 않은 일이었다.

가령, `[[]()]` 같은 문자열이면, `[[](` 부분까지 해서 스택에 `[(`가 저장되어 있고 `3`이라는 값이 `numInsideBracket`이라 하자. 그러면, 괄호를 닫는 `)`에서 이 값이 `2`가 되고 `3`과 더해서 괄호 안쪽의 `5`라는 것은 어떻게 구분하겠는가? 또, `[[([])([])]]` 같은 구조가 된다면, 어디까지가 합이고 어디까지가 곱인지는 어떻게 구분하겠는가?

이런 누적 변수는 이 문제에서 가장 위험한 방식의 코드이다. 괄호 구조가 복잡해질수록, 계산 흐름이 망가지기 때문이다. 그래서 중첩 구조를 처리하기 위해서는 **계산이 끝날 때마다 명확히 그 값을 확정하고 기록해야 한다.**

### 유효하지 않은 괄호열을 언제, 어떻게 판단할까?
처음에는 유효하지 않은 괄호열을 아예 중간에 판단해서 중단하려고 시도했었다. 

```java
				...
				} else {
                    result = 0;
                    break;
                }
            } else stack.push(input.charAt(i));
        }

        bw.write(result + "\n");
        bw.flush();
    }
}
```
중간중간에 저렇게 `else`문을 두어서 `for`를 강제로 `break`하는 방식이었는데, 이것 역시 확실한 단점이 존재했다. 유효하지 않은 괄호열이 어떻게 주어질 지 모르는 것이다. 예를 들어, `[[]]]]]`같이 `]`가 뒤에 많이 부여되는 경우, `]`를 검사할 때 스택이 비어 있으면 끝낼 수 있다. 그러면, `[[[[[]]`처럼 되면 어떡해야 하는가? 그리고, `[(])`처럼 꼬여 있으면 어떻게 해야 하는가? `([][([([[(]]])])])`는?

괄호열의 구조가 복잡해질 수록, 어떠한 경우의 수를 분리하여 각각의 상황에 대처하기란 쉽지 않다. 그렇기 때문에 **아예 괄호열의 판단을 미뤄버리는 것은 어떤가**&ZeroWidthSpace;라는 아이디어에 도달할 수 있다. 처리되지 않으면 그냥 그대로 `push`해버리고, 처리되면 그때그때 `pop`을 거치면서 맨 마지막에 **모든 계산을 완료했음에도 괄호가 남아있다**&ZeroWidthSpace;면 그때는 우리가 '유효하지 않다'라고 판단할 수 있다는 것이다.

### 중요한 발상 : 꼭 스택에 괄호만 넣고 확인해야 하는가
문제에서도 아마 힌트를 준 셈이나 마찬가지인데, `(X)`라는 것에서 `X`가 유효한 괄호열이라면 `X`의 괄호값의 2배가 된다. 그러면, `X`를 계산했을 때 굳이 어떤 값을 계속 변수에 집어넣고 괄호 안인지 밖인지 구분하기 어려워하기보다는,  `Stack<Object>` 같은 형태로 아예 숫자고 문자고 집어넣고 처리하면 되지 않을까? 이 아이디어가 생각보다 중요하다.

---

이 점에 착안하여 코드를 짜면 되는 것이다.

## 코드화
### main 메소드 - (1) 기본 세팅
```java
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));

        Stack<Object> stack = new Stack<>();
        String input = br.readLine();
        int result = 0;
        boolean isAns = true;
```
입력을 받아서 `input`이라는 `String` 변수에 저장했고, 스택은 맨 마지막 발상처럼 `Object`를 모두 받을 수 있는 형태로 선언하였다. `result`는 값 계산을 위한 변수이며, `isAns`는 맨 마지막에 유효성 검사를 위한 `boolean` 변수이다.

### main 메소드 - (2) 스택 처리 과정
```java
		...
        for (int i = 0; i < input.length(); i++) {
            if (input.charAt(i) == '(' || input.charAt(i) == '[') {
                stack.push(input.charAt(i));
            } else if (input.charAt(i) == ')') {
                int innerSum = 0;
                while (!stack.isEmpty() && stack.peek() instanceof Integer)
                    innerSum += (int) stack.pop();
                if (!stack.isEmpty() && stack.peek().equals('(')) {
                    stack.pop();
                    stack.push(innerSum == 0 ? 2 : innerSum * 2);
                } else stack.push(')');
            } else if (input.charAt(i) == ']') {
                int innerSum = 0;
                while (!stack.isEmpty() && stack.peek() instanceof Integer)
                    innerSum += (int) stack.pop();
                if (!stack.isEmpty() && stack.peek().equals('[')) {
                    stack.pop();
                    stack.push(innerSum == 0 ? 3 : innerSum * 3);
                } else stack.push(']');
            }
        }
```

`for` 문을 돌려서 괄호열에서 괄호를 하나씩 받아온다.

- 만약 `(`나 `[`의 여는 괄호라면 부담 없이 `push`해둔다.
- `)`의 닫는 소괄호일 때는, 우선 `innerSum`이라는 변수를 선언해준다.
  - 만약에, 이 괄호 안에 다른 작은 괄호들이 있어서 계산이 필요한 경우 (가령, `([][())`같은 경우)에는 이미 스택 안에 숫자가 있을 것이다.
  - 그래서 그 숫자를 처리하기 위해서 우리는 `while`문에서 이전까지의 스택이 비어있지 않으면서, 맨 위에 있는 것이 숫자인 경우(`instanceof Integer`) 그것을 `innerSum`이라는 변수에 `pop()`으로 꺼내서 `return`되는 값에 대해 합하게 했다.
  - 그리고 그렇게 한 결과 비어있지 않으면서 맨 위에 `(`가 맞물린다면, `innerSum`이 있다면 그 안의 값을 2배해주고, 아니라면 `()`의 최소상태라는 것이므로 2로 바꿔준다.
  - 잘못된 괄호열은 나중에 처리할 것이므로 모든 마지막 `else`문은 닫는 괄호를 `push`해주는 것이다.
- `]`의 닫는 대괄호일 때도 사실상 `)`와 다를 것이 하나도 없다. 그저 각각의 배수나 값에 대한 차이 정도 빼면 로직이 모두 같다.

### main 메소드 - (3) 마지막 계산 및 유효하지 않은 괄호열 관리, 그리고 출력
```java
		...
        for (Object obj : stack) {
            if (obj instanceof Integer) result += (int) obj;
            else {
                isAns = false;
                break;
            }
        }

        bw.write(isAns ? result + "\n" : 0 + "\n");
        bw.flush();
    }
}
```

여기에서는 남은 스택에 있는 객체들을 받아온다.

- 정상적인 상태로 처리되는 값들이라면, 맨 마지막에는 큰 범위로 나눈 숫자들만이 남게 된다. 가령, `(())[()]`인 경우 `4 6`이 남을 것이고, `()[]()[](())`인 경우 `2 3 2 3 4`가 남을 것이다.
- 유효한 괄호열은 숫자만 남을 것이므로 `instanceof`를 통해 구분하여 `result`에 모두 더해주기만 한다. 더할 게 없이 하나의 큰 괄호 안에 둘러싸여 있다면, 최종값만이 `stack`내에 한 개의 값으로 남을 것이므로 상관 없다.
- 하지만 유효하지 않은 괄호열이라면 안에 숫자가 아닌 것이 있을 것이다. `if`문의 `instanceof`를 통해 구분되기 때문에 `else`를 활용하여 이전에 선언한 `isAns` 변수를 `false`로 바꾸고 `break`한다.

마지막에는 `isAns`의 여부에 따라 불가능하다면 0을, 아니라면 `result`의 값을 그냥 출력해주면 끝.

## 정리
자료구조의 활용이나 계산에 있어서 생각하기 쉬웠지만, 처리 분기를 어떻게 나누고 어떤 방식으로 값을 다룰지에 대한 것은 생각보다 쉽지 않았다.
