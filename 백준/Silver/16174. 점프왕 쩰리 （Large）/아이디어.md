# 아이디어
DFS 혹은 BFS를 사용하는 것이 좋겠는데, BFS의 경우는 dx-dy 배열을 어떻게 운용할지 생각해보면 생각보다 간단한 답이 나온다.

## 문제 파악하기
‘쩰리’는 점프하는 것을 좋아하는 젤리다. 단순히 점프하는 것에 지루함을 느낀 ‘쩰리’는 새로운 점프 게임을 해보고 싶어 한다. 새로운 점프 게임의 조건은 다음과 같다.

- ‘쩰리’는 가로와 세로의 칸 수가 같은 정사각형의 구역 내부에서만 움직일 수 있다. ‘쩰리’가 정사각형 구역의 외부로 나가는 경우엔 바닥으로 떨어져 즉시 게임에서 패배하게 된다.
- ‘쩰리’의 출발점은 항상 정사각형의 가장 왼쪽, 가장 위의 칸이다. 다른 출발점에서는 출발하지 않는다.
- ‘쩰리’가 이동 가능한 방향은 오른쪽과 아래 뿐이다. 위쪽과 왼쪽으로는 이동할 수 없다.
- ‘쩰리’가 가장 오른쪽, 가장 아래 칸에 도달하는 순간, 그 즉시 ‘쩰리’의 승리로 게임은 종료된다.
- ‘쩰리’가 한 번에 이동할 수 있는 칸의 수는, 현재 밟고 있는 칸에 쓰여 있는 수 만큼이다. 칸에 쓰여 있는 수 초과나 그 미만으로 이동할 수 없다.

새로운 게임이 맘에 든 ‘쩰리’는, 계속 게임을 진행해 마침내 최종 단계에 도달했다. 하지만, 게임을 진행하는 구역이 너무 넓어져버린 나머지, 이 게임에서 이길 수 있는지 없는지 가늠할 수 없어졌다. ‘쩰리’는 유능한 프로그래머인 당신에게 주어진 구역에서 승리할 수 있는 지 알아봐 달라고 부탁했다. ‘쩰리’를 도와 주어진 게임 구역에서 끝 점(오른쪽 맨 아래 칸)까지 도달할 수 있는지를 알아보자!

---

입력은 다음과 같이 주어진다:
- 첫 줄에는 게임 구역 크기 $N$이 $2 ≤ N ≤ 64$ 범위로 주어진다.
- 둘째 줄부터 마지막 줄까지 게임판의 구역(맵)이 주어진다.
- 게임판의 승리 지점(오른쪽 맨 아래 칸)에는 -1이 적혀 있고, 나머지 칸에는 0 이상 100 이하의 정수가 쓰여있다.

출력으로 '쩰리'가 끝 점에 도달할 수 있으면 "HaruHaru"(인용부호 없이), 도달할 수 없으면 "Hing"(인용부호 없이)을 한 줄에 출력한다.

## 방법 고안

### BFS를 사용하려고 한다면 dx-dy를 어떻게 운용해야 하는가?
BFS(너비 우선 탐색)를 활용하여 운용하게 된다고 한다면, 일반적으로는
```java
int[] dx = new int[] {-1, 1, 0, 0};
int[] dy = new int[] {0, 0, -1, 1};
```
의 형태로 하여 주변 십자를 탐색하게 된다. 그런데, 이 문제에서 '쩰리'는 오른쪽과 아래로만 움직이며 왼쪽과 위쪽으로는 움직이지 않는다. 그리고, 해당 칸에 있는 수 만큼 이동할 뿐 그것보다 작거나 크게 움직이지 않는다. 그러므로, 큐에서 한 개의 위치를 꺼냈다고 한다면
```java
while (!queue.isEmpty()) {
	int[] cur = queue.poll();
    int posX = cur[0], posY = cur[1], moveLen = map[posY][posX];
    
    int[] dx = {moveLen, 0};
    int[] dy = {0, moveLen};
    
    ...
}
```
해당 지점에 대해서 `moveLen`, 즉 그 칸에 있는 숫자를 꺼내어 dx-dy를 우측 혹은 하단으로 움직이게만 만들게 하는 것이다. 그러면 두 배열을 순회하여 움직이면 되겠다.

### DFS와 BFS 어느 쪽이 나을까?
어차피 전체 칸을 순회해야 하기 때문에 크게 상관은 없다. 다만, DFS(깊이 우선 탐색)의 경우에는 맨 마지막 지점에 도달하기 전까지 한 경우에 대해서 쭉 이동하다가 아니면 다시 돌아오는 구조(재귀 함수를 활용한)이고, BFS(너비 우선 탐색)의 경우에는 맨  마지막 지점에 도달하기 전까지 모든 경우를 따지면서 Queue를 운용하는 구조이다. 이 문제에서는 도달이 가능한지 아닌지의 여부만 파악하면 되기 때문에 어느쪽을 사용하든 크게 문제가 되지는 않는다.

---

## 코드화
### BFS 메소드 운용
```java
public class Main {
    public static int N;
    public static int[][] map;
    public static boolean[][] visited;

    public static void bfs() {
        Queue<int[]> Q = new ArrayDeque<>();
        Q.offer(new int[] {0, 0});
        visited[0][0] = true;

        while (!Q.isEmpty()) {
            int[] cur = Q.poll();
            int posX = cur[0], posY = cur[1], moveLen = map[posY][posX];

            int[] dx = {moveLen, 0};
            int[] dy = {0, moveLen};

            for (int i = 0; i < 2; i++) {
                int nx = posX + dx[i], ny = posY + dy[i];
                if (nx >= 0 && nx < N && ny >= 0 && ny < N && !visited[ny][nx]) {
                    visited[ny][nx] = true;
                    if (nx == N - 1 && ny == N - 1) return;
                    Q.offer(new int[] {nx, ny});
                }
            }
        }
    }
```
`int[][]` 이차원 배열 `map`은 전체 맵을 저장하는 배열이며, `boolean[][]` 이차원 배열 `visited`는 방문 여부를 확인하는 배열이다. `int` 배열 `N`으로 크기를 전역으로 선언해두었다.

`bfs` 알고리즘은 다음과 같이 구현한다.

- `bfs()`의 시작 지점이 `(0, 0)`으로 고정이므로 parameter는 두지 않았다. `Q`라는 큐 구조 안에 존재하는 값을 받아오면서 방문하지 않은 곳을 계속 순회한다.
- Queue에서 좌표를 하나씩 꺼내어 순회한다. 이 지점을 각각 `posX`, `posY`라는 변수에 좌표를 지정한다. 그 지점에 적힌 움직여야 할 칸으로까지의 거리를 `moveLen`으로 둔다. 그러면 dx-dy 배열을 오른쪽 혹은 아래로만 움직이게 코드를 바꾼다.
- 해당 값이 '범위 내에 존재'하는지와 방문하지 않은 곳인지 체크한 다음, 만약 그게 모두 맞다면 `visited` 배열에서 방문했다고 남기기 위해 `true`로 설정한다. 오른쪽 아래 끝 부분에 도달했다면, `return`으로 바로 종료해준다. 그렇지 않다면 그 지점을 Queue에 추가한다.

### main 메소드
```java
	...
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        N = Integer.parseInt(br.readLine());

        map = new int[N][N];
        visited = new boolean[N][N];

        for (int i = 0; i < N; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            for (int j = 0; j < N; j++) {
                map[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        bfs();
        System.out.println(visited[N-1][N-1] ? "HaruHaru" : "Hing");
    }
}
```

메인 메소드에서는 배열을 초기화하고 입력을 받아서 `bfs()`를 돌리면 된다. `return`으로 나오든 모두 돌고 나오든 간에 BFS를 다 돌고 나왔다면 `visited[N-1][N-1]` 즉 도달해야 하는 지점이 `true`로 될 것이기 때문에 삼항 연산자를 통해 경우에 따라 출력하게 하였다.

## 정리
dx-dy 배열을 활용하는 방식을 유연하게 할 수 있었어야 하는 문제이다.

아래의 경우처럼 사용하면, DFS로도 이 문제를 풀 수 있다.
```java
import java.io.*;
import java.util.*;

public class Main {
    public static int N;
    public static int[][] map;
    public static boolean[][] visited;

    public static void bfs(int posX, int posY) {
        int moveLen = map[posY][posX];
        int[] dx = {moveLen, 0};
        int[] dy = {0, moveLen};

        for (int i = 0; i < 2; i++) {
            int nx = posX + dx[i], ny = posY + dy[i];
            if (nx >= 0 && nx < N && ny >= 0 && ny < N && !visited[ny][nx]) {
                visited[ny][nx] = true;
                if (nx == N - 1 && ny == N - 1) return;
                bfs(nx, ny);
            }
        }
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        N = Integer.parseInt(br.readLine());

        map = new int[N][N];
        visited = new boolean[N][N];

        for (int i = 0; i < N; i++) {
            StringTokenizer st = new StringTokenizer(br.readLine());
            for (int j = 0; j < N; j++) {
                map[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        bfs(0, 0);
        System.out.println(visited[N-1][N-1] ? "HaruHaru" : "Hing");
    }
}
```
