# 아이디어
집합을 잘 사용하면 쉽게 풀린다.

## 문제 파악하기
몇 개의 자연수로 이루어진 두 집합 $A$와 $B$가 있다. 집합 $A$에는 속하면서 집합 $B$에는 속하지 않는 모든 원소를 구하는 프로그램을 작성하자.

---

입력은 다음과 같이 주어진다:
- 첫째 줄에는 집합 $A$의 원소의 개수 $n(A)$와 집합 $B$의 원소의 개수 $n(B)$가 빈 칸을 사이에 두고 주어진다.
- $n(A)$와 $n(B)$ 모두 50만 이하의 자연수로 주어진다.
- 둘째 줄에는 집합 $A$의 원소가, 셋째 줄에는 집합 $B$의 원소가 각 원소 사이에 빈 칸을 두고 주어진다.
- 한 집합의 원소는 $2,147,483,647$ 이하의 자연수이며, 하나의 집합에 속하는 모든 원소의 값은 다름이 보장된다.

출력은 다음과 같게 하자:
- 첫째 줄에는 집합 $A$에 속하면서 $B$에는 속하지 않는 차집합 $A-B$의 원소의 개수를 출력한다.
- 다음 줄에는 구체적인 원소를 빈 칸을 사이에 두고, **증가하는 순서**&ZeroWidthSpace;로 출력한다.
- 차집합이 공집합이라면 첫째 줄에 0만을 출력하면 된다.

## 방법 고안
`HashSet`을 사용하여 풀면 되는 문제라, 그게 설명할 건 없다. 사실상 여기 적힌 건 여담에 가깝다.

### HashSet 구조에 contains()를 사용하지 않아도 된다

```java
public class HashSet<E> {
	...
    public boolean remove(Object o) {
    	return map.remove(o) == PRESENT;
    }
```
`HashSet.java`를 뜯어보면, `remove()` 메소드 자체에서 `return` 구조에 `== PRESENT`라는, 존재 여부를 확인하는 구문이 보인다. 그리고 그 설명을 보면, 다음과 같이 적혀 있다.

> Removes the specified element from this set if it is present. More formally, removes an element `e` such that `Objects.equals(o, e)`, if this set contains such an element. Returns true if this set contained the element (or equivalently, if this set changed as a result of the call). (This set will not contain the element once the call returns.)   
>
> Params:   
> `o` – object to be removed from this set, **if present**   
> Returns:   
> `true` if the set **contained the specified element** 

즉, `HashSet` 내에 `remove`로 지우려 하는 `Object`가 없다고 해서 크게 문제가 되지 않는다는 것이므로 우리는 굳이 `contains()`를 활용할 필요 없이 그저 `remove()`만 호출하면 된다.

---

## 코드화
### 전체 코드
```java
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringBuilder sb = new StringBuilder();

        StringTokenizer st = new StringTokenizer(br.readLine());
        int setANum = Integer.parseInt(st.nextToken()), setBNum = Integer.parseInt(st.nextToken());

        HashSet<Integer> compSet = new HashSet<>();
        st = new StringTokenizer(br.readLine());
        for (int i = 0; i < setANum; i++)
            compSet.add(Integer.parseInt(st.nextToken()));

        st = new StringTokenizer(br.readLine());
        for (int j = 0; j < setBNum; j++) {
            int target = Integer.parseInt(st.nextToken());
            compSet.remove(target);
        }

        sb.append(compSet.size()).append("\n");
        if (!compSet.isEmpty()) {
            List<Integer> list = new ArrayList<>(compSet);
            Collections.sort(list);
            for (int temp : list) sb.append(temp).append(" ");
        }

        System.out.print(sb);
    }
}
```
입력으로 `setANum`과 `setBNum`을 받아와 그 수만큼, `compSet`에 각각 집합 $A$의 원소를 `compSet.add()`로 삽입해주고, $B$의 원소가 있으면 `compSet.remove()`로 삭제해준다. 그리고, `compSet.size()`로 메소드를 통해 원소 개수를 입력해준 다음 그 개수가 0, 즉 공집합이 아닐 때는 그 값을 모두 `ArrayList`에 받아와서 `Collections.sort()`를 통해 정렬해준 다음 모두 출력해주면 된다.

## 정리
`HashSet` 내부 구조를 얼떨결에 보게 되어서 `remove()` 메소드가 굳이 원소를 포함하고 있는지 아닌지 확인하지 않아도 작동한다는 것을 알게 되었다. 난이도 자체는 크게 어렵지 않은 문제.
