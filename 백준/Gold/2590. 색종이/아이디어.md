# 아이디어
분기문을 굉-장히 많이 나눠주면 되는, 이런 이유로 골드 난이도인가 싶은 문제

## 문제 파악하기
![](https://velog.velcdn.com/images/aoi-aoba/post/426995c8-6f91-4f48-97ab-b1b7f6615289/image.png)

각 변이 $n$ cm인 정사각형 모양의 $n$번 색종이가 1~6번까지 총 6종류가 있다. 주어진 색종이를 

![](https://velog.velcdn.com/images/aoi-aoba/post/772b32b4-4c99-4f00-a4e6-6d27d1b49e05/image.png)

6×6 크기의 격자 판 위에 붙이려고 한다. 색종이를 붙일 때는 색종이가 판의 경계 밖으로 삐져나가서는 안 되며, 색종이가 서로 겹쳐서도 안 된다. 또한, 하나의 색종이는 하나의 판에만 붙여야 한다.

- 입력으로 첫 번째 줄부터 여섯 번째 줄까지 각 종류의 색종이 장수가 1~6번까지 차례대로 주어진다.
- 각 종류의 색종이 장수는 최대 100장이다.
- 출력으로 답을 첫째 줄에 필요한 판의 최소 개수로 출력하면 된다.

## 방법 고안
태그에 '많은 조건 분기'가 붙어있을 정도다. 조건을 많이많이 나누면서, 직접 확인해서, 그걸 if-else 혹은 while(condition) 등을 적절히 사용하여 풀면 된다.

### 5번 색종이와 6번 색종이는 풀기 편하다
![](https://velog.velcdn.com/images/aoi-aoba/post/30534c37-e461-4bd1-8cbb-0b68936ecf6f/image.png)

6번 색종이의 경우는 오른쪽처럼 한 격자를 모두 채워버리기 때문에 상관없다. 5번 색종이의 경우를 보자. 남은 공간이 1번 색종이 크기로 11장이 들어갈 수 있다. 그러므로, 1번 색종이가 만약 11장보다 많게 남았다면 11장만 넣으면 되고, 11장 이하로 남았다면 그냥 다 붙여버리면 그리드에 모두 붙일 수 있다.

> 6번 색종이는 $N$개 존재할 때 $N$개의 그리드를 필요로 함   
> 5번 색종이는 $N$개 존재한다고 하면, $N$개의 그리드를 만들 수 있고, 각 그리드 당 1번 색종이가 11개 들어갈 수 있으므로 $11N$ 만큼의 1번 색종이를 추가 그리드 없이 커버 가능함

### 4번 색종이는 2번 색종이와 1번 색종이의 케이스로 나누자

![](https://velog.velcdn.com/images/aoi-aoba/post/78408f89-5d92-436d-88ae-ab328cfbc256/image.png)

4번 색종이는 우선 한 개의 그리드에 1장을 붙일 수 있으므로 장수별로 격자를 우선 만들자. 그 안에는 왼쪽 그림처럼 2번 색종이가 5장 들어갈 수 있다.
- 4번 색종이 장수만큼 그리드를 만든다.
- 그 그리드 하나당 2번 색종이가 5장 커버된다.
- 그것보다 많으면, 2번 색종이를 그만큼 삭제하면 된다.
- 그것보다 적으면, 2번 색종이를 다 붙인 다음 남는 칸만큼 1번을 붙인다.

> 4번 색종이가 $N$개 존재할 때 만들어야 하는 그리드는 $N$개   
> 그리드 당 2번 색종이가 5개 들어가므로 $5N$  만큼의 1번 색종이 커버 가능   
> 그래도 남는 공간이 있다면, $5N+K$의 형태로 2번 색종이를 표현해서 남는 $K$ 만큼을 한 그리드에 붙이면 $20-4K$ 크기에 1번 색종이가 들어감

맨 마지막이 이해가 안 될 수 있는데, 예시를 들어보자.
- 4번 색종이가 3장 존재한다면 3개의 그리드가 추가된다.
- 2번 색종이가 여기에서 15장 커버되는데, 만약 $12 (= 5 × 2 + 2)$장이 있다 하자.
- 그러면 2개 그리드를 채우고 남은 그리드에 2장을 붙이면 위의 그림 중 오른쪽처럼 아래 공간이 남고, 그 크기는 $20 - 4 × 2$로 $K = 2$인 상황이다.

### 3번 색종이는 자기 자신부터 생각하고 케이스를 더 나눠야 한다

![](https://velog.velcdn.com/images/aoi-aoba/post/50f90e0c-74be-464a-bad4-931ff3c0f10d/image.png)

3번 색종이는 그리드 하나에 최대 4장이 들어갈 수 있다. 그러므로 우선, 4개로 최대한 많은 그리드들을 생성하자. 그러면 $4N+K$의 형태로 만들어서 케이스를 나눌 수 있다.
- $K=3$일 때, 2번은 1장, 1번은 5장 들어갈 수 있다.
- $K=2$일 때, 2번은 3장, 1번은 6장 들어갈 수 있다.
- $K=1$일 때, 2번은 5장, 1번은 7장 들어갈 수 있다.

이걸 각각의 종이가 얼마나 남았나에 따라 채우면 된다. 저대로 채워줄 수 있다면 채우면 되지만, 만약 그게 되지 않는다면? 예시를 들어보자.

- 3번 색종이가 6장이 있다고 하면 $K=2$ 케이스로 들어간다.
- 그런데 만약 2번 색종이가 2장밖에 없다면?
- 그러면 3번 색종이 2개를 사용했으므로 남는 공간 18 중에서 2번 색종이 2개를 사용하여 $18-4*2=10$이므로 1번 색종이를 10장 이상 남았으면 10장 붙이고, 아니면 남은 것 전부 붙이면 된다.

> 3번 색종이가 $N = 4P + K$개 존재할 때 만들어야 하는 그리드는 $P$개. 즉, $\lfloor P / 4 \rfloor$개   
> $K$의 값에 따라 그리드 내에 들어갈 수 있는 2번 색종이와 1번 색종이의 순서쌍을 고려하여 집어넣음   
> 순서쌍과 맞지 않게 2번 색종이가 부족해지면 1번으로 채울 수 있게 그 값을 계산해줘야 할 것

### 2번 색종이와 1번 색종이는 그냥 자기 자신으로 열심히 채워보자

![](https://velog.velcdn.com/images/aoi-aoba/post/b45740f9-11ef-4ec4-a9c3-7c14a6443864/image.png)

2번 색종이는 한 개의 그리드에 총 9개가 들어갈 수 있다. 그러면 9개씩 그리드를 만들고, 남은 것은 1번 색종이로 채우면 된다. 1번 색종이는 아예 최소기 때문에, 한 개의 그리드에 36개가 들어간다는 것만 고려해서 쭉쭉 채워나가면 된다. 하지만 큰 색종이부터 붙일 거기 때문에 거의 고려할 사항이 아닐 수준이다.

> 2번 색종이가 $P = 9N+ K$장으로 구성된다면 $N$개의 그리드를 만들고, $36-4K$만큼의 크기에 1번 색종이를 붙이면 됨   
> 1번 색종이는 $P = 36N + K$장으로 구성된다면 $N$개의 그리드를 만들고 $K$개를 붙일 한 개의 그리드를 또 만들면 됨

---
이를 기반으로 코드를 구성하면 된다.

## 코드화
### 기본 설정 및 main 메소드
```java
public class Main {
    static int PAPER_TYPES = 6;
    static int[] papers = new int[PAPER_TYPES];
    ...
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        for (int i = 0; i < PAPER_TYPES; i++) papers[i] = Integer.parseInt(br.readLine());
        bw.write(String.valueOf(countGrids()));
        bw.flush();
    }
}
```
`PAPER_TYPES`는 사실상 그냥 상수 선언이다. 그리고, `papers`라는 `int[]` 배열 객체에 값을 저장해주고, `countGrids()`라는 메소드를 호출해서 그대로 답하게 한다. 계산은 다 `countGrids()` 안에 있다!

### countGrids 메소드 - 6번 색종이
```java
	...
	public static int countGrids() {
        int result = 0;
        if (papers[5] > 0) { // 6번 색종이는 한 장으로 판이 꽉 찬다
            result += papers[5];
            papers[5] = 0;
        }
```
6번 색종이는 그냥 한 장 당 하나를 추가하면 된다. 결과값을 저장하는 `result` 변수의 값을 한 장당 1씩 올려주면 된다.

### countGrids 메소드 - 5번 색종이
```java
		...
        if (papers[4] > 0) {
            result += papers[4]; // 5번 색종이만큼의 그리드를 모두 만들어서 붙이고
            if (papers[0] > 0) {
                if (papers[0] >= papers[4] * 11) papers[0] -= papers[4] * 11;
                // 5번 색종이를 붙인 그리드의 남은 공간에는 1번 색종이가 11장 들어갈 수 있음
                else papers[0] = 0;
                // 그것보다 적다면 그냥 다 붙이고 끝내면 됨
            }
            papers[4] = 0;
        }
```
위에서 설명한 대로, 그리드 하나 당 11장의 1번 색종이가 커버 가능함을 감안하여 붙이면 된다.

### countGrids 메소드 - 4번 색종이
```java
		...
        if (papers[3] > 0) {
            result += papers[3];
            if (papers[1] >= papers[3] * 5) {
                papers[1] -= papers[3] * 5; 
            } else {
                int leftSize =  4 * 5 * papers[3] - 4 * papers[1];
                papers[1] = 0;
                papers[0] = papers[0] >= leftSize ? papers[0] - leftSize : 0;
            }
            papers[3] = 0;
        }
```
위에서 설명한 대로 진행하면 되는데,
- 우선, 4번 색종이만큼의 그리드를 `result`에 추가한다.
- 4번 색종이만 붙인 그리드의 남은 공간에 2번 색종이가 5장 들어갈 수 있는데, 그것보다 많다면 붙일 수 있는 만큼 붙이고 끝낸다.
- 근데 그 커버할 수 있는 공간보다 개수가 부족해서 공간이 남는다면, `leftSize`에서 계산한다.

> 계산식이 `int leftSize =  4 * 5 * papers[3] - 4 * papers[1];`로 되는 이유는, 4번 종이 개수만큼 만든 그리드 하나당 20만큼의 크기가 남고 (36-16이므로) 거기에서 2번 색종이를 붙인 만큼이기 때문이다.

- 그렇게 하면, 일단 `papers[1]`은 다 붙일 수 있음이 자명하며, 남은 공간은 다 1번으로 붙이면 된다.
- 삼항 연산자는 남은 1번 색종이가 허용 가능 크기보다 덜 있을 수 있다는 걸 감안하기 위한 것이므로, `papers[0] = Math.max(papers[0]-leftSize, 0)`로 해도 좋다.

### countGrids 메소드 - 3번 색종이
```java
		...
        if (papers[2] > 0) { // 3번 색종이는 자기 자신만으로도 모두 채워질 수 있음에 유의
            result += papers[2] / 4; // 3번 색종이 4개당 한 개의 그리드 채울 수 있음
            papers[2] %= 4;
            if (papers[2] > 0) {
                result++; // 4개가 안 되는 것들은 한 개의 그리드로 처리 가능함
                int use2 = 0;
                // 3번이 3장 채워지면 3*3만 남음. 잘 써봐야 2번은 1장임.
                if (papers[2] == 3) {
                    use2 = Math.min(papers[1], 1);
                    papers[0] = Math.max(0, papers[0] - (9 - 4 * use2));
                } else if (papers[2] == 2) { // 3번이 2장 채워지면 3*6 남고 최대 3장 쓸 수 있음
                    use2 = Math.min(papers[1], 3);
                    papers[0] = Math.max(0, papers[0] - (18 - 4 * use2));
                } else { // 3번이 1장 채워지면 3*3*3 남고 최대 5장 쓸 수 있음
                    use2 = Math.min(papers[1], 5);
                    papers[0] = Math.max(0, papers[0] - (27 - 4 * use2));
                }
                papers[1] -= use2;
            }
            papers[2] = 0;
        }
        if 
```
위에서 설명한 대로 케이스를 세부적으로 나눠주면 된다.
- 우선, 3번이 자기 자신 4개당 한 개의 그리드를 채울 수 있다.
- 그걸 이용해 `result`를 추가하고 4로 나눈 나머지를 구한다.
- 4로 나눈 나머지가 존재하는 경우 (위에서는 $K > 0$ 일 때로 설명했다) 각각의 장수에 대해서 사용 가능한 장수를 `Math.min()`을 활용하여 구해주었다. 이것은, 2번 색종이가 커버 가능한 장수보다 적을 가능성을 감안한 것이다.
- 그리고 3*3이 몇 장인지에 따라 남은 크기가 각각 9, 18, 27이므로 거기에서 사용한 2번 색종이인 `use2`를 4를 곱해 빼서, 그 남은 공간에 대해 1번을 붙여주면 된다. `Math.max()`를 통해서 음수로 접근하지 않게 방지해준 것이다.

### countGrids 메소드 - 2, 1번 색종이
```java
		...
        if (papers[1] > 0) { // 2번 색종이는 자기 자신만으로도 모두 채워질 수 있음에 유의
            result += papers[1] / 9; // 2번 색종이 9개당 한 개의 그리드 채울 수 있음
            papers[1] %= 9;
            if (papers[1] > 0) { // 2번 색종이가 만약 남았다면
                result++;
                int leftSize = 36 - 4 * papers[1];
                papers[0] = papers[0] >= leftSize ? papers[0] - leftSize : 0;
            }
            papers[1] = 0;
        }
        if (papers[0] > 0) {
            result += papers[0] / 36; // 1번 색종이 36장 당 한 개의 그리드 채울 수 있음
            if (papers[0] % 36 > 0) result++;
            papers[0] = 0;
        }
        return result;
    }
```
2번 색종이는 9로 나눈 몫으로 `result`에 더하고, 나머지를 구해서 남은 만큼을 36이라는 전체 크기에서 4를 곱해 뺀 `leftSize`를 전체 1번 색종이로 붙여주면 된다. 1번 색종이는 36으로 나눈 몫으로 `result`에 더하고, 나머지를 구하여 나머지가 있다면 그건 한 개의 그리드로 해결되므로 1을 추가해주면 된다.

그렇게 모든 과정을 마치면, `result`를 `return`하면 끝.

## 정리
문제 태그가 그렇게 되어 있기도 하고, 어쩔 수 없이 이렇게 분기를 많이 나눠서 풀어야 할 수밖에 없었던 문제이다. 그래도 72ms가 뜨는 걸 보면, 적당한 방법으로 잘 푼 것 같다.
