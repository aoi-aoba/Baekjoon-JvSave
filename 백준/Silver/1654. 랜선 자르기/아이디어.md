# 아이디어
이분 탐색(이진 탐색)을 이용하여 푸는 문제

## 문제 파악하기
박성원이 캠프 때 쓸 $N$개의 랜선을 만들어야 해서 영식에게 도움을 청했고, 자체적으로 $K$개의 랜선을 가진 영식은 각각 길이가 모두 다른 랜선에 대하여 $N$개의 같은 길이의 랜선으로 만들고 싶어서 이들을 잘라서 만들기로 한다.
- 300cm의 랜선이 있다고 하면, 140cm 랜선을 두 개 잘라내면 20cm는 버려진다. 즉, 이미 자른 랜선은 붙일 수 없고 모든 랜선은 $K$개의 랜선에서 잘라서 만들어진다.
- 랜선을 자르거나 만들 때 손실되는 길이는 없다고 가정한다.
- 기존  $K$개의 랜선으로 $N$개의 랜선이 만들어지는 경우는 없다고 가정한다. 그리고 항상 cm 단위로 정수길이만큼 자른다.
- $N$개 이상 만들어지는 것 역시 $N$개를 만드는 것으로 포함한다.

입력은 다음과 같이 주어진다.
- 첫째 줄에는 영식이 가지고 있는 랜선 개수 $K$가 1만 이하의 정수로, 필요한 랜선의 개수 $N$이 100만 이하의 정수로 주어지고 항상 $K≤N$으로 주어진다.
- 그 후 $K$줄에 걸쳐서 이미 가지고 있는 각 랜선 길이가 cm 단위의 정수로 입력된다.
- 랜선의 길이는 $2^{31}-1
$ 이하의 자연수로 주어진다.

만들 수 있는 최대 랜선의 길이를 cm 단위의 정수로 출력하자.

## 방법 고안
이 문제는 최댓값을 구해야 하는데, 특정 조건(랜선의 개수) 만족의 가장 긴 길이를 구해야 하지만 단순이 훑는 것으로는 어려워 보인다. 여기에서 파악할 수 있는 것은, 어떤 길이로 자르게 되면 만들 수 있는 개수는 길이에 따라 단조적으로 감소한다. 즉, 길이가 줄어들수록 많아지고, 길이가 늘어날수록 랜선 수가 줄어든다. 이걸 잘 활용하면 직접 다 해보지 않아도 되는데, 정답 범위를 설정해서 그 안에서 좁혀나가면 된다. 즉, '이분 탐색(이진 탐색, Binary Search)'을 사용하는 것이 유리하다.

기본적으로 1cm 이상 잘라야 할 것이므로 1~ $p$라는 범위를 두고 이분 탐색을 진행해서, 어떻게 하든 간에 중간값을 움직이는 과정에서 맨 마지막에는 우리가 원하는 '최대의 길이'가 범위 내의 최대로 잡혀 있을 것이므로 그걸 출력하면 된다.

가령, 예제 코드에 제시된
> 802cm, 743cm, 457cm, 539cm 4개로 11개 랜선 만들기

를 생각해본다면...
- 1~802로 두고 중간값인 401에 대해서 생각했을 때 5개 랜선이 만들어지고 11개보다 작으므로 범위를 1~400으로 설정
- 중간값인 200에 대해서 생각했을 때 11개 랜선이 만들어지고 11개와 같으므로 범위를 201~400으로 설정
- 중간값인 300에 대해서 생각했을 때 6개 랜선이 만들어지고 11개보다 작으므로 범위를 201~299으로 설정
- 중간값인 250에 대해서 생각했을 때 8개 랜선이 만들어지고 11개보다 작으므로 범위를 201~249으로 설정
- 중간값인 225에 대해서 생각했을 때 10개 랜선이 만들어지고 11개보다 작으므로 범위를 201~224로 설정
- 중간값인 212에 대해서 생각했을 때 10개 랜선이 만들어지고 11개보다 작으므로 범위를 201~211로 설정
- 중간값인 206에 대해서 생각했을 때 10개 랜선이 만들어지고 11개보다 작으므로 범위를 201~205로 설정
- 중간값인 203에 대해서 생각했을 때 10개 랜선이 만들어지고 11개보다 작으므로 범위를 201~202로 설정
- 중간값인 201에 대해서 생각했을 때 10개 랜선이 만들어지고 11개보다 작으므로 범위를 재설정해야 할 때, 최소가 201이고 최대가 200인 상태로 뒤집히므로 종료, 최대를 출력하면 200

어떤 방식으로든 최대를 출력할 수 있다.

## 코드화
```java
public class Main {
    public static long target;
    public static long binarySearch(long[] arr, long low, long high) {
        if (low > high) return high;
        long mid = (low + high) / 2, num = 0;
        for (long temp : arr) num += temp / mid;
        if (num < target) return binarySearch(arr, low, mid-1);
        else return binarySearch(arr, mid+1, high);
    }
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        StringTokenizer st = new StringTokenizer(br.readLine());
        int K = Integer.parseInt(st.nextToken());
        long max = 0;
        target = Integer.parseInt(st.nextToken());
        long[] arr = new long[K];
        for (int i = 0; i < K; i++) {
            arr[i] = Long.parseLong(br.readLine());
            max = Math.max(arr[i], max);
        }
        System.out.println(binarySearch(arr, 1, max));
        br.close();
    }
}
```

코드 작동이 직관적인 형태이기 때문에 추가적인 설명은 생략하도록 한다. 그저 일반적인 Binary Search를 사용해주면 된다. 대신, 중간에 있는 for 루프에서 확인하는 `num`은 만들 수 있는 랜선의 개수를 파악하는 것이다. 종료조건은 `low > high`의 상태로 설정한다. 그리고 오버플로우가 날 수 있기 때문에 `long`을 사용해주었다.

## 정리
이진 탐색 범위의 길이 기준으로 보면 $\log_2(\text{maxLength})$이기 때문에, 각 이진 탐색 반복에서 수행되는 연산에 $O(K)$가 소모되는 것을 감안하면 전체 시간 복잡도는 $O(K\cdot\log_2(\text{maxLength}))$로서 최악의 경우 31만 정도가 계산되므로 매우 빠르게 처리할 수 있다. 
