# 아이디어
몇 개 조금 끄적여보면 규칙성이 보인다!

## 일반화가 필요한 수학문제
이 문제를 시간 내에 풀려면 일단 알고리즘적으로 반복하면 문제가 클 거라는 것을 직감하고, 몇 개 써보기로 결정했다.

### 테스트 케이스 직접 작성해보기
- $$f(x)$$가 $$x$$의 모든 약수를 더한 값
- $$g(x)$$가 $$x$$보다 작거나 같은 모든 자연수에 대한 함수 f의 함숫값의 합

위와 같이 주어졌으므로 직접 써보자!   

$$f(1) = 1$$
$$g(1) = 1$$

$$f(2) = 1 + 2$$
$$g(2) = 1 × 2 + 1$$

$$f(3) = 1 + 3$$
$$g(3) = 1 × 3 + 2 × 1 + 3 × 1$$

$$f(4) = 1 + 2 + 4$$
$$g(4) = 1 × 4 + 2 × 2 + 3 × 1 + 4 × 1$$

어디까지 캐치했을지는 모르겠지만, 여기 정도면 캐치할 수 있었다.

- 1은 모든 수의 약수이므로 모든 자연수의 개수만큼 등장한다.
- 2는 2의 배수의 약수이므로 2의 배수 개수만큼 등장한다.
- 3은 3의 배수의 약수이므로 3의 배수 개수만큼 등장한다.

> 일반성을 잃지 않고 $$g(x)$$에서 주어진 $$x$$ 이하의 자연수는 $$x$$의 배수 개수만큼 존재한다.

다음 규칙에 의하면 결국 모든 수를 자신보다 작은 자연수에 대해 나눴을 때 **나머지는 무시한 상태로 몫만 챙기면** 해당 자연수가 몇 번 약수로서 나타나는지 알 수 있다는 것이다. 그걸 그 자연수에 다시 곱해서 그 값들을 모두 더해주면 된다.

### 바닥함수(가우스 함수) 활용하여 식 재편성
결과적으로 말하자면, $$g(x)$$라는 함수는 다음과 같다 :
> $$x$$ 이하의 자연수 $$a$$에 대하여 $$a × [x ÷ a]$$의 합

바닥 함수(가우스 함수)가 등장해서 좀 당황스러울 수도 있겠지만, 결과적으로 가우스 함수는 `x/a` 로 했을 때 프로그래밍 언어가 지원하는 나눗셈 연산자를 통해 소수를 버린 상태의 정수 형태가 되므로 굉장히 간단한 코드가 됨을 알 수 있다.

## 문제 생각 시간보다 구현 시간이 훨씬 적다
```JAVA
public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        long n = Long.parseLong(br.readLine()), result = 0;
        for(int i=1; i<=n; i++)
            result += i * (n / i);
        System.out.println(result);
        br.close();
    }
}
```
결과적으로 저 식을 직접 구현만 해주면 된다.   
`for` 문을 활용해도 그저 O(n)이면 해결되므로 시간 복잡도 역시 크게 영향을 받지 않는다.
